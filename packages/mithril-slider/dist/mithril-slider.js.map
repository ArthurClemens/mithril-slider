{"version":3,"file":"mithril-slider.js","sources":["../src/prop.js","../src/touch.js","../src/classes.js","../src/index.js","../src/css.js"],"sourcesContent":["\nexport default x => {\n  let p = x;\n  return args => {\n    if (args === undefined) {\n      return p;\n    } else {\n      p = args;\n    }\n  };\n};\n","import Hammer from \"hammerjs\";\n\nexport const Touch = ({ el, orientation, onStart, onMove, onEnd }) => {\n  const hammer = new Hammer.Manager(el, {});\n  hammer.add(new Hammer.Pan({\n    direction: orientation === \"vertical\"\n      ? Hammer.DIRECTION_VERTICAL\n      : orientation === \"all\"\n        ? Hammer.DIRECTION_ALL\n        : Hammer.DIRECTION_HORIZONTAL,\n    threshold: 0\n  }));\n  hammer.on(\"panstart\", onStart);\n  hammer.on(\"panmove\", onMove);\n  hammer.on(\"panend\", onEnd);\n\n  return {\n    destroy: () => {\n      hammer.off(\"panstart\", onStart);\n      hammer.off(\"panmove\", onMove);\n      hammer.off(\"panend\", onEnd);\n    }\n  };\n};","\nexport const classes = {\n  slider:    \"mithril-slider\",\n  content:   \"mithril-slider__content\",\n  before:    \"mithril-slider__before\",\n  after:     \"mithril-slider__after\"\n};\n","import m from \"mithril\";\nimport prop from \"./prop\";\nimport { Touch } from \"./touch\";\nimport { classes } from \"./classes\";\n\nconst DEFAULT_DURATION = 160;\nconst DEFAULT_CANCEL_DRAG_FACTOR = 1 / 5;\nconst DEFAULT_GROUP_SIZE = 1;\nconst DEFAULT_ORIENTATION = \"vertical\";\nconst DEFAULT_DIRECTION = 1;\nconst DEFAULT_OFFSET_X = 0;\nconst DEFAULT_OFFSET_Y = 0;\n\nconst view = ({state, attrs}) => {\n  if (attrs.sliderController) {\n    attrs.sliderController(state);\n  }\n  const currentIndex = state.index();\n  // sizes need to be set each redraw because of screen resizes\n  state.groupBy(attrs.groupBy || 1);\n  const contentEl = state.contentEl;\n  if (contentEl) {\n    state.updateContentSize(contentEl);\n  }\n  return m(\"div\",\n    {\n      class: [\n        classes.slider,\n        attrs.class || \"\"\n      ].join(\" \")\n    },\n    [\n      attrs.before\n        ? m(\".\" + classes.before, attrs.before)\n        : null,\n      m(\"div\",\n        {\n          class: classes.content,\n          onupdate: ({dom}) => {\n            if (state.inited) {\n              return;\n            }\n            if (dom.childNodes.length > 0) {\n              state.setContentEl(dom);\n              state.updateContentSize(dom);\n              state.touch = new Touch({\n                el: dom,\n                orientation: attrs.orientation,\n                onStart: state.handleDragStart,\n                onMove: state.handleDrag,\n                onEnd: state.handleDragEnd\n              });\n              state.inited = true;\n            }\n          },\n          onremove: () => state.touch && state.touch.destroy()\n        },\n        state.list().map((data, listIndex) =>\n          attrs.page({\n            data,\n            listIndex,\n            currentIndex\n          })\n        )\n      ),\n      attrs.after\n        ? m(\".\" + classes.after, attrs.after)\n        : null\n    ]\n  );\n};\n\nconst oninit = vnode => {\n  const attrs = vnode.attrs;\n  const list = prop([]);\n  if (attrs.pageData) {\n    attrs.pageData().then(result => initWithResult(result));\n  }\n  const duration = parseInt(attrs.duration, 10) || DEFAULT_DURATION;\n  const index = prop(attrs.index || -1);\n  let contentEl;\n  let pageSize = 0;\n  const groupBy = prop(attrs.groupBy || DEFAULT_GROUP_SIZE);\n  const cancelDragFactor = attrs.cancelDragFactor || DEFAULT_CANCEL_DRAG_FACTOR;\n  const isVertical = attrs.orientation === DEFAULT_ORIENTATION;\n  const dir = attrs.rtl ? -1 : DEFAULT_DIRECTION;\n  const pageOffsetX = attrs.pageOffsetX || DEFAULT_OFFSET_X;\n  const pageOffsetY = attrs.pageOffsetY || DEFAULT_OFFSET_Y;\n\n  const initWithResult = result => {\n    list(result);\n    // First redraw so that pages are drawn\n    // continuation in view's oncreate\n    m.redraw();\n  };\n\n  const setIndex = idx => {\n    const oldIndex = index();\n    if (oldIndex !== idx) {\n      index(idx);\n      m.redraw();\n      if (attrs.getState) {\n        const el = contentEl;\n        const page = getPageEl(el, index());\n        attrs.getState({\n          index: idx,\n          hasNext: hasNext(),\n          hasPrevious: hasPrevious(),\n          pageEl: page\n        });\n      }\n    }\n  };\n\n  const getPageEl = (el, idx) => el.childNodes[idx];\n\n  const createAttrs = value => {\n    const x = isVertical ? \"0\" : value + \"px\";\n    const y = isVertical ? value + \"px\" : \"0\";\n    const z = \"0\";\n    const attrs = [x, y, z].join(\", \");\n    return \"translate3d(\" + attrs + \")\";\n  };\n\n  const setTransitionStyle = (el, value) => {\n    const style = el.style;\n    style.transform = style[\"-webkit-transform\"] = style[\"-moz-transform\"] = style[\"-ms-transform\"] = createAttrs(value);\n  };\n\n  const setTransitionDurationStyle = duration => {\n    contentEl.style[\"-webkit-transition-duration\"] = contentEl.style[\"transition-duration\"] = duration + \"ms\";\n  };\n\n  const goTo = (idx, duration) => {\n    if (idx < 0 || idx > list().length - 1) {\n      return;\n    }\n    updateContentSize(contentEl);\n    if (duration !== undefined) {\n      setTransitionDurationStyle(duration);\n    }\n    setTransitionStyle(contentEl, -dir * idx * pageSize);\n    setIndex(idx);\n  };\n\n  const normalizedStep = (orientation = 0) => {\n    const idx = index();\n    const size = groupBy();\n    const min = 0;\n    const max = list().length;\n    const next = idx + (orientation * size);\n    // make sure that last item aligns at the right\n    if ((next + size) > max) {\n      return max - size;\n    }\n    if (next < min) {\n      return min;\n    }\n    return next;\n  };\n\n  const updateContentSize = el => {\n    const prop = isVertical ? \"height\" : \"width\";\n    const page = el.childNodes[0];\n    if (page.getBoundingClientRect()[prop]) {\n      pageSize = page.getBoundingClientRect()[prop];\n      el.style[prop] = (list().length * pageSize) + \"px\";\n    }\n  };\n\n  const goCurrent = (duration = 0) => {\n    updateContentSize(contentEl);\n    setTransitionDurationStyle(duration);\n    goTo(normalizedStep());\n  };\n\n  const goNext = (dur = duration) => (\n    setTransitionDurationStyle(dur),\n    index() < list().length ? goTo(normalizedStep(1)) : goTo(normalizedStep())\n  );\n\n  const goPrevious = (dur = duration) => (\n    setTransitionDurationStyle(dur),\n    index() > 0 ? goTo(normalizedStep(-1)) : goTo(normalizedStep())\n  );\n\n  const hasNext = () => index() + groupBy() < list().length;\n\n  const hasPrevious = () => index() > 0;\n\n  const setContentEl = el => {\n    contentEl = el;\n    updateContentSize(el);\n    goCurrent();\n  };\n\n  const handleDragStart = () => (\n    updateContentSize(contentEl),\n    setTransitionDurationStyle(0)\n  );\n\n  const handleDrag = e => {\n    const el = contentEl;\n    const page = getPageEl(el, index());\n    const delta = isVertical\n      ? e.deltaY + pageOffsetY\n      : e.deltaX + pageOffsetX;\n    const origin = isVertical\n      ? page.offsetTop\n      : dir === -1\n        ? page.offsetLeft - page.parentNode.clientWidth + page.clientWidth\n        : page.offsetLeft;\n    setTransitionStyle(el, delta - origin);\n    e.preventDefault();\n  };\n\n  const calculateTransitionDuration = velocity => {\n    const el = contentEl;\n    const page = getPageEl(el, index());\n    const width = page.clientWidth;\n    const speed = Math.abs(velocity) || 1;\n    let dur = 1 / speed * width;\n    if (dur > duration) {\n      dur = duration;\n    }\n    return dur;\n  };\n\n  const handleDragEnd = e => {\n    const dur = calculateTransitionDuration(e.velocity);\n    const delta = isVertical ? e.deltaY : e.deltaX;\n    if (Math.abs(delta) > pageSize * groupBy() * cancelDragFactor) {\n      if (dir * delta < 0) {\n        goNext(dur);\n      } else {\n        goPrevious(dur);\n      }\n    } else {\n      goCurrent(dur);\n    }\n  };\n\n  vnode.state = {\n    // component methods\n    list,\n    contentEl,\n    setContentEl,\n    handleDrag,\n    handleDragStart,\n    handleDragEnd,\n    groupBy,\n    updateContentSize,\n\n    // public interface\n    index,\n    hasNext,\n    hasPrevious,\n    goTo,\n    goCurrent,\n    goNext,\n    goPrevious\n  };\n};\n\nexport const slider = {\n  oninit,\n  view\n};\n","\nexport const css = [{\n  \".mithril-slider\": {\n    overflow: \"hidden\",\n\n    \" .mithril-slider__content\": {\n      transitionProperty: \"transform\",\n      transitionTimingFunction: \"ease-out\",\n      // transition-duration set in js\n      transform: \"translate3d(0, 0, 0)\"\n    }\n  }\n}];\n\n"],"names":["p","x","undefined","args","Touch","el","orientation","onStart","onMove","onEnd","hammer","Hammer","Manager","add","Pan","DIRECTION_VERTICAL","DIRECTION_ALL","DIRECTION_HORIZONTAL","on","off","classes","DEFAULT_DURATION","DEFAULT_CANCEL_DRAG_FACTOR","DEFAULT_GROUP_SIZE","DEFAULT_ORIENTATION","DEFAULT_DIRECTION","DEFAULT_OFFSET_X","DEFAULT_OFFSET_Y","view","state","attrs","sliderController","currentIndex","index","groupBy","contentEl","updateContentSize","m","slider","class","join","before","content","dom","inited","childNodes","length","setContentEl","touch","handleDragStart","handleDrag","handleDragEnd","destroy","list","map","data","listIndex","page","after","oninit","vnode","prop","pageData","then","initWithResult","result","duration","parseInt","pageSize","cancelDragFactor","isVertical","dir","rtl","pageOffsetX","pageOffsetY","redraw","setIndex","oldIndex","idx","getState","getPageEl","hasNext","hasPrevious","createAttrs","value","y","z","setTransitionStyle","style","transform","setTransitionDurationStyle","goTo","normalizedStep","size","min","max","next","getBoundingClientRect","goCurrent","goNext","dur","goPrevious","delta","e","deltaY","deltaX","origin","offsetTop","offsetLeft","parentNode","clientWidth","preventDefault","calculateTransitionDuration","width","speed","Math","abs","velocity","css"],"mappings":"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"}