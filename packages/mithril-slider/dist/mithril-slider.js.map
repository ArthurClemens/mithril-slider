{"version":3,"file":"mithril-slider.js","sources":["../src/classes.js","../src/styler.js","../src/css.js","../src/index.js"],"sourcesContent":["\nexport const classes = {\n  slider:    \"slider\",\n  content:   \"content\",\n  before:    \"before\",\n  after:     \"after\"\n};\n","import { prefixPlugin } from \"j2c-plugin-prefix-browser\";\nimport J2c from \"j2c\";\nconst j2c = new J2c(prefixPlugin);\n\n/*\n * @param id: identifier, used as HTMLElement id for the attached <style></style> element\n * @param styles: list of lists style Objects\n */\nexport const addStyle = (id, ...styles) => {\n  removeStyle(id);\n  const styleEl = document.createElement(\"style\");\n  if (id) {\n    styleEl.setAttribute(\"id\", id);\n  }\n  styles.forEach((styleList) => {\n    // each style returns a list\n    if (Object.keys(styleList).length) {\n      styleList.forEach((style) => {\n        const scoped = { \"@global\": style };\n        const sheet = j2c.sheet(scoped);\n        styleEl.appendChild(document.createTextNode(sheet));\n      });\n    }\n  });\n  document.head.appendChild(styleEl);\n};\n\nconst removeStyle = id => {\n  if (id) {\n    const old = document.getElementById(id);\n    if (old) {\n      old.parentNode.removeChild(old);\n    }\n  }\n};","import { addStyle } from \"./styler\";\n\nconst styles = [{\n  \".slider\": {\n    overflow: \"hidden\",\n\n    \" .content\": {\n      transitionProperty: \"transform\",\n      transitionTimingFunction: \"ease-out\",\n      // transition-duration set in js\n      transform: \"translate3d(0, 0, 0)\"\n    }\n  }\n}];\n\naddStyle(\"mithril-slider\", styles);\n","import m from \"mithril\";\nimport Hammer from \"hammerjs\";\nimport { classes } from \"./classes\";\nimport \"./css\";\n\nconst view = (ctrl, opts) => {\n  if (opts.sliderController) {\n    opts.sliderController(ctrl);\n  }\n  const currentIndex = ctrl.index();\n  // sizes need to be set each redraw because of screen resizes\n  ctrl.groupBy(opts.groupBy || 1);\n  const contentEl = ctrl.contentEl();\n  if (contentEl) {\n    ctrl.updateContentSize(contentEl);\n  }\n  return m(\"div\",\n    {\n      class: [\n        classes.slider,\n        opts.class || \"\"\n      ].join(\" \")\n    },\n    [\n      opts.before\n        ? m(\".\" + classes.before, opts.before)\n        : null,\n      m(\"div\",\n        {\n          class: classes.content,\n          config: (el, inited, context) => {\n            if (context.inited) {\n              return;\n            }\n            if (el.childNodes.length > 0) {\n              ctrl.setContentEl(el);\n              ctrl.updateContentSize(el);\n\n              const mc = new Hammer.Manager(el, {});\n              mc.add(new Hammer.Pan({\n                direction: opts.orientation === \"vertical\"\n                  ? Hammer.DIRECTION_VERTICAL\n                  : opts.orientation === \"all\"\n                  ? Hammer.DIRECTION_ALL\n                  : Hammer.DIRECTION_HORIZONTAL,\n                threshold: 0\n              }));\n              mc.on(\"panmove\", ctrl.handleDrag);\n              mc.on(\"panend\", ctrl.handleDragEnd);\n              mc.on(\"panstart\", ctrl.handleDragStart);\n              context.onunload = () => {\n                mc.off(\"panmove\", ctrl.handleDrag);\n                mc.off(\"panend\", ctrl.handleDragEnd);\n                mc.off(\"panstart\", ctrl.handleDragStart);\n              };\n              context.inited = true;\n            }\n          }\n        },\n        ctrl.list().map((data, listIndex) =>\n          opts.page({\n            data,\n            listIndex,\n            currentIndex\n          })\n        )\n      ),\n      opts.after\n        ? m(\".\" + classes.after, opts.after)\n        : null\n    ]\n  );\n};\n\n\nconst controller = (opts = {}) => {\n  let list = m.prop([]);\n  if (opts.pageData) {\n    opts.pageData().then(result => initWithResult(result));\n  }\n  const defaultDuration = parseInt(opts.duration, 10) || 160;\n  const index = m.prop(opts.index || -1);\n  const contentEl = m.prop();\n  let pageSize = 0;\n  const groupBy = m.prop(opts.groupBy || 1);\n  const cancelDragFactor = opts.cancelDragFactor || (1 / 5);\n  const isVertical = opts.orientation === \"vertical\";\n  const dir = opts.rtl ? -1 : 1;\n  const pageOffsetX = opts.pageOffsetX || 0;\n  const pageOffsetY = opts.pageOffsetY || 0;\n\n  const initWithResult = result => {\n    list(result);\n    // First redraw so that pages are drawn\n    // continuation in view's config\n    m.redraw();\n  };\n\n  const setIndex = idx => {\n    const oldIndex = index();\n    if (oldIndex !== idx) {\n      index(idx);\n      m.redraw();\n      if (opts.getState) {\n        const el = contentEl();\n        const page = getPageEl(el, index());\n        opts.getState({\n          index: idx,\n          hasNext: hasNext(),\n          hasPrevious: hasPrevious(),\n          pageEl: page\n        });\n      }\n    }\n  };\n\n  const getPageEl = (el, idx) => el.childNodes[idx];\n\n  const createAttrs = value => {\n    const x = isVertical ? \"0\" : value + \"px\";\n    const y = isVertical ? value + \"px\" : \"0\";\n    const z = \"0\";\n    const attrs = [x, y, z].join(\", \");\n    return \"translate3d(\" + attrs + \")\";\n  };\n\n  const setTransitionStyle = (el, value) => {\n    const style = el.style;\n    style.transform = style[\"-webkit-transform\"] = style[\"-moz-transform\"] = style[\"-ms-transform\"] = createAttrs(value);\n  };\n\n  const setTransitionDurationStyle = duration => {\n    contentEl().style[\"-webkit-transition-duration\"] = contentEl().style[\"transition-duration\"] = duration + \"ms\";\n  };\n\n  const goTo = (idx, duration) => {\n    if (idx < 0 || idx > list().length - 1) {\n      return;\n    }\n    updateContentSize(contentEl());\n    if (duration !== undefined) {\n      setTransitionDurationStyle(duration);\n    }\n    setTransitionStyle(contentEl(), -dir * idx * pageSize);\n    setIndex(idx);\n  };\n\n  const normalizedStep = (orientation = 0) => {\n    const idx = index();\n    const size = groupBy();\n    const min = 0;\n    const max = list().length;\n    const next = idx + (orientation * size);\n    // make sure that last item aligns at the right\n    if ((next + size) > max) {\n      return max - size;\n    }\n    if (next < min) {\n      return min;\n    }\n    return next;\n  };\n\n  const updateContentSize = el => {\n    const prop = isVertical ? \"height\" : \"width\";\n    const page = el.childNodes[0];\n    if (page.getBoundingClientRect()[prop]) {\n      pageSize = page.getBoundingClientRect()[prop];\n      el.style[prop] = (list().length * pageSize) + \"px\";\n    }\n  };\n\n  const goCurrent = (duration = 0) => {\n    updateContentSize(contentEl());\n    setTransitionDurationStyle(duration);\n    goTo(normalizedStep());\n  };\n\n  const goNext = (duration = defaultDuration) => (\n    setTransitionDurationStyle(duration),\n    index() < list().length ? goTo(normalizedStep(1)) : goTo(normalizedStep())\n  );\n\n  const goPrevious = (duration = defaultDuration) => (\n    setTransitionDurationStyle(duration),\n    index() > 0 ? goTo(normalizedStep(-1)) : goTo(normalizedStep())\n  );\n\n  const hasNext = () => index() + groupBy() < list().length;\n\n  const hasPrevious = () => index() > 0;\n\n  const setContentEl = el => {\n    contentEl(el);\n    updateContentSize(el);\n    goCurrent();\n  };\n\n  const handleDragStart = () => (\n    updateContentSize(contentEl()),\n    setTransitionDurationStyle(0)\n  );\n\n  const handleDrag = e => {\n    const el = contentEl();\n    const page = getPageEl(el, index());\n    const delta = isVertical\n      ? e.deltaY + pageOffsetY\n      : e.deltaX + pageOffsetX;\n    const origin = isVertical\n      ? page.offsetTop\n      : dir === -1\n        ? page.offsetLeft - page.parentNode.clientWidth + page.clientWidth\n        : page.offsetLeft;\n    setTransitionStyle(el, delta - origin);\n    e.preventDefault();\n  };\n\n  const calculateTransitionDuration = velocity => {\n    const el = contentEl();\n    const page = getPageEl(el, index());\n    const width = page.clientWidth;\n    const speed = Math.abs(velocity) || 1;\n    let duration = 1 / speed * width;\n    if (duration > defaultDuration) {\n      duration = defaultDuration;\n    }\n    return duration;\n  };\n\n  const handleDragEnd = e => {\n    const duration = calculateTransitionDuration(e.velocity);\n    const delta = isVertical ? e.deltaY : e.deltaX;\n    if (Math.abs(delta) > pageSize * groupBy() * cancelDragFactor) {\n      if (dir * delta < 0) {\n        goNext(duration);\n      } else {\n        goPrevious(duration);\n      }\n    } else {\n      goCurrent(duration);\n    }\n  };\n\n  return {\n    // component methods\n    list,\n    contentEl,\n    setContentEl,\n    handleDrag,\n    handleDragStart,\n    handleDragEnd,\n    groupBy,\n    updateContentSize,\n    // registerPage,\n\n    // public interface\n    index,\n    hasNext,\n    hasPrevious,\n    goTo,\n    goCurrent,\n    goNext,\n    goPrevious\n  };\n};\n\nexport const slider = {\n  controller,\n  view\n};\n"],"names":["classes","j2c","J2c","prefixPlugin","addStyle","id","styles","styleEl","document","createElement","setAttribute","forEach","styleList","Object","keys","length","style","scoped","@global","sheet","appendChild","createTextNode","head","removeStyle","old","getElementById","parentNode","removeChild","view","ctrl","opts","sliderController","currentIndex","index","groupBy","contentEl","updateContentSize","m","slider","class","join","before","content","el","inited","context","childNodes","setContentEl","mc","Hammer","Manager","add","Pan","orientation","DIRECTION_VERTICAL","DIRECTION_ALL","DIRECTION_HORIZONTAL","on","handleDrag","handleDragEnd","handleDragStart","onunload","off","list","map","data","listIndex","page","after","controller","prop","pageData","then","initWithResult","result","defaultDuration","parseInt","duration","pageSize","cancelDragFactor","isVertical","dir","rtl","pageOffsetX","pageOffsetY","redraw","setIndex","oldIndex","idx","getState","getPageEl","hasNext","hasPrevious","createAttrs","x","value","y","z","attrs","setTransitionStyle","transform","setTransitionDurationStyle","goTo","undefined","normalizedStep","size","min","max","next","getBoundingClientRect","goCurrent","goNext","goPrevious","delta","e","deltaY","deltaX","origin","offsetTop","offsetLeft","clientWidth","preventDefault","calculateTransitionDuration","width","speed","Math","abs","velocity"],"mappings":"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"}