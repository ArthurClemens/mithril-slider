{"version":3,"file":"mithril-slider.js","sources":["../src/classes.js","../src/index.js","../src/css.js"],"sourcesContent":["\nexport const classes = {\n  slider:    \"slider\",\n  content:   \"content\",\n  before:    \"before\",\n  after:     \"after\"\n};\n","import m from \"mithril\";\nimport Hammer from \"hammerjs\";\nimport { classes } from \"./classes\";\n\nconst view = (ctrl, opts) => {\n  if (opts.sliderController) {\n    opts.sliderController(ctrl);\n  }\n  const currentIndex = ctrl.index();\n  // sizes need to be set each redraw because of screen resizes\n  ctrl.groupBy(opts.groupBy || 1);\n  const contentEl = ctrl.contentEl();\n  if (contentEl) {\n    ctrl.updateContentSize(contentEl);\n  }\n  return m(\"div\",\n    {\n      class: [\n        classes.slider,\n        opts.class || \"\"\n      ].join(\" \")\n    },\n    [\n      opts.before\n        ? m(\".\" + classes.before, opts.before)\n        : null,\n      m(\"div\",\n        {\n          class: classes.content,\n          config: (el, inited, context) => {\n            if (context.inited) {\n              return;\n            }\n            if (el.childNodes.length > 0) {\n              ctrl.setContentEl(el);\n              ctrl.updateContentSize(el);\n\n              const mc = new Hammer.Manager(el, {});\n              mc.add(new Hammer.Pan({\n                direction: opts.orientation === \"vertical\"\n                  ? Hammer.DIRECTION_VERTICAL\n                  : opts.orientation === \"all\"\n                  ? Hammer.DIRECTION_ALL\n                  : Hammer.DIRECTION_HORIZONTAL,\n                threshold: 0\n              }));\n              mc.on(\"panmove\", ctrl.handleDrag);\n              mc.on(\"panend\", ctrl.handleDragEnd);\n              mc.on(\"panstart\", ctrl.handleDragStart);\n              context.onunload = () => {\n                mc.off(\"panmove\", ctrl.handleDrag);\n                mc.off(\"panend\", ctrl.handleDragEnd);\n                mc.off(\"panstart\", ctrl.handleDragStart);\n              };\n              context.inited = true;\n            }\n          }\n        },\n        ctrl.list().map((data, listIndex) =>\n          opts.page({\n            data,\n            listIndex,\n            currentIndex\n          })\n        )\n      ),\n      opts.after\n        ? m(\".\" + classes.after, opts.after)\n        : null\n    ]\n  );\n};\n\nconst controller = (opts = {}) => {\n  const list = m.prop([]);\n  if (opts.pageData) {\n    opts.pageData().then(result => initWithResult(result));\n  }\n  const defaultDuration = parseInt(opts.duration, 10) || 160;\n  const index = m.prop(opts.index || -1);\n  const contentEl = m.prop();\n  let pageSize = 0;\n  const groupBy = m.prop(opts.groupBy || 1);\n  const cancelDragFactor = opts.cancelDragFactor || (1 / 5);\n  const isVertical = opts.orientation === \"vertical\";\n  const dir = opts.rtl ? -1 : 1;\n  const pageOffsetX = opts.pageOffsetX || 0;\n  const pageOffsetY = opts.pageOffsetY || 0;\n\n  const initWithResult = result => {\n    list(result);\n    // First redraw so that pages are drawn\n    // continuation in view's config\n    m.redraw();\n  };\n\n  const setIndex = idx => {\n    const oldIndex = index();\n    if (oldIndex !== idx) {\n      index(idx);\n      m.redraw();\n      if (opts.getState) {\n        const el = contentEl();\n        const page = getPageEl(el, index());\n        opts.getState({\n          index: idx,\n          hasNext: hasNext(),\n          hasPrevious: hasPrevious(),\n          pageEl: page\n        });\n      }\n    }\n  };\n\n  const getPageEl = (el, idx) => el.childNodes[idx];\n\n  const createAttrs = value => {\n    const x = isVertical ? \"0\" : value + \"px\";\n    const y = isVertical ? value + \"px\" : \"0\";\n    const z = \"0\";\n    const attrs = [x, y, z].join(\", \");\n    return \"translate3d(\" + attrs + \")\";\n  };\n\n  const setTransitionStyle = (el, value) => {\n    const style = el.style;\n    style.transform = style[\"-webkit-transform\"] = style[\"-moz-transform\"] = style[\"-ms-transform\"] = createAttrs(value);\n  };\n\n  const setTransitionDurationStyle = duration => {\n    contentEl().style[\"-webkit-transition-duration\"] = contentEl().style[\"transition-duration\"] = duration + \"ms\";\n  };\n\n  const goTo = (idx, duration) => {\n    if (idx < 0 || idx > list().length - 1) {\n      return;\n    }\n    updateContentSize(contentEl());\n    if (duration !== undefined) {\n      setTransitionDurationStyle(duration);\n    }\n    setTransitionStyle(contentEl(), -dir * idx * pageSize);\n    setIndex(idx);\n  };\n\n  const normalizedStep = (orientation = 0) => {\n    const idx = index();\n    const size = groupBy();\n    const min = 0;\n    const max = list().length;\n    const next = idx + (orientation * size);\n    // make sure that last item aligns at the right\n    if ((next + size) > max) {\n      return max - size;\n    }\n    if (next < min) {\n      return min;\n    }\n    return next;\n  };\n\n  const updateContentSize = el => {\n    const prop = isVertical ? \"height\" : \"width\";\n    const page = el.childNodes[0];\n    if (page.getBoundingClientRect()[prop]) {\n      pageSize = page.getBoundingClientRect()[prop];\n      el.style[prop] = (list().length * pageSize) + \"px\";\n    }\n  };\n\n  const goCurrent = (duration = 0) => {\n    updateContentSize(contentEl());\n    setTransitionDurationStyle(duration);\n    goTo(normalizedStep());\n  };\n\n  const goNext = (duration = defaultDuration) => (\n    setTransitionDurationStyle(duration),\n    index() < list().length ? goTo(normalizedStep(1)) : goTo(normalizedStep())\n  );\n\n  const goPrevious = (duration = defaultDuration) => (\n    setTransitionDurationStyle(duration),\n    index() > 0 ? goTo(normalizedStep(-1)) : goTo(normalizedStep())\n  );\n\n  const hasNext = () => index() + groupBy() < list().length;\n\n  const hasPrevious = () => index() > 0;\n\n  const setContentEl = el => {\n    contentEl(el);\n    updateContentSize(el);\n    goCurrent();\n  };\n\n  const handleDragStart = () => (\n    updateContentSize(contentEl()),\n    setTransitionDurationStyle(0)\n  );\n\n  const handleDrag = e => {\n    const el = contentEl();\n    const page = getPageEl(el, index());\n    const delta = isVertical\n      ? e.deltaY + pageOffsetY\n      : e.deltaX + pageOffsetX;\n    const origin = isVertical\n      ? page.offsetTop\n      : dir === -1\n        ? page.offsetLeft - page.parentNode.clientWidth + page.clientWidth\n        : page.offsetLeft;\n    setTransitionStyle(el, delta - origin);\n    e.preventDefault();\n  };\n\n  const calculateTransitionDuration = velocity => {\n    const el = contentEl();\n    const page = getPageEl(el, index());\n    const width = page.clientWidth;\n    const speed = Math.abs(velocity) || 1;\n    let duration = 1 / speed * width;\n    if (duration > defaultDuration) {\n      duration = defaultDuration;\n    }\n    return duration;\n  };\n\n  const handleDragEnd = e => {\n    const duration = calculateTransitionDuration(e.velocity);\n    const delta = isVertical ? e.deltaY : e.deltaX;\n    if (Math.abs(delta) > pageSize * groupBy() * cancelDragFactor) {\n      if (dir * delta < 0) {\n        goNext(duration);\n      } else {\n        goPrevious(duration);\n      }\n    } else {\n      goCurrent(duration);\n    }\n  };\n\n  return {\n    // component methods\n    list,\n    contentEl,\n    setContentEl,\n    handleDrag,\n    handleDragStart,\n    handleDragEnd,\n    groupBy,\n    updateContentSize,\n\n    // public interface\n    index,\n    hasNext,\n    hasPrevious,\n    goTo,\n    goCurrent,\n    goNext,\n    goPrevious\n  };\n};\n\nexport const slider = {\n  controller,\n  view\n};\n","\nexport const css = [{\n  \".slider\": {\n    overflow: \"hidden\",\n\n    \" .content\": {\n      transitionProperty: \"transform\",\n      transitionTimingFunction: \"ease-out\",\n      // transition-duration set in js\n      transform: \"translate3d(0, 0, 0)\"\n    }\n  }\n}];\n\n"],"names":["classes","view","ctrl","opts","sliderController","currentIndex","index","groupBy","contentEl","updateContentSize","m","slider","class","join","before","content","el","inited","context","childNodes","length","setContentEl","mc","Hammer","Manager","add","Pan","orientation","DIRECTION_VERTICAL","DIRECTION_ALL","DIRECTION_HORIZONTAL","on","handleDrag","handleDragEnd","handleDragStart","onunload","off","list","map","data","listIndex","page","after","controller","prop","pageData","then","initWithResult","result","defaultDuration","parseInt","duration","pageSize","cancelDragFactor","isVertical","dir","rtl","pageOffsetX","pageOffsetY","redraw","setIndex","oldIndex","idx","getState","getPageEl","hasNext","hasPrevious","createAttrs","x","value","y","z","attrs","setTransitionStyle","style","transform","setTransitionDurationStyle","goTo","undefined","normalizedStep","size","min","max","next","getBoundingClientRect","goCurrent","goNext","goPrevious","delta","e","deltaY","deltaX","origin","offsetTop","offsetLeft","parentNode","clientWidth","preventDefault","calculateTransitionDuration","width","speed","Math","abs","velocity","css"],"mappings":"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"}