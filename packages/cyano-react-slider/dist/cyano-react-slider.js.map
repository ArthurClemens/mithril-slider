{"version":3,"file":"cyano-react-slider.js","sources":["../../cyano-core-slider/dist/cyano-core-slider.mjs","../node_modules/cyano-react/dist/cyano-react.mjs","../src/index.js"],"sourcesContent":["function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nconst classes = {\n  slider: \"mithril-slider\",\n  content: \"mithril-slider__content\",\n  before: \"mithril-slider__before\",\n  after: \"mithril-slider__after\"\n};\n\nfunction O(a, b) {\n  if (arguments.length == 1) {\n    if (this instanceof O) this.apply = typeof a == 'function' ? a : function (b) {\n      return O(b != null ? b : {}, a);\n    };else return new O(a);\n  } else if (a == null) return arguments.length > 2 ? O.call.apply(O, arguments) : b;else {\n    a = copy(a);\n\n    for (var i = 1; i < arguments.length; i++, b = arguments[i]) for (var key in b) if (b.hasOwnProperty(key)) b[key] == O ? delete a[key] : a[key] = b[key] instanceof O ? b[key].apply(typeof a[key] == 'object' ? copy(a[key]) : a[key]) : b[key];\n\n    return a;\n  }\n}\n\nfunction copy(x) {\n  var y = new x.constructor();\n\n  for (var z in x) if (x.hasOwnProperty(z)) y[z] = x[z];\n\n  return y;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar hammer = createCommonjsModule(function (module) {\n/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function (window, document, exportName, undefined$1) {\n\n  var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\n  var TEST_ELEMENT = document.createElement('div');\n  var TYPE_FUNCTION = 'function';\n  var round = Math.round;\n  var abs = Math.abs;\n  var now = Date.now;\n  /**\n   * set a timeout with a given scope\n   * @param {Function} fn\n   * @param {Number} timeout\n   * @param {Object} context\n   * @returns {number}\n   */\n\n  function setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n  }\n  /**\n   * if the argument is an array, we want to execute the fn on each entry\n   * if it aint an array we don't want to do a thing.\n   * this is used by all the methods that accept a single and array argument.\n   * @param {*|Array} arg\n   * @param {String} fn\n   * @param {Object} [context]\n   * @returns {Boolean}\n   */\n\n\n  function invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n      each(arg, context[fn], context);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * walk objects and arrays\n   * @param {Object} obj\n   * @param {Function} iterator\n   * @param {Object} context\n   */\n\n\n  function each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n      return;\n    }\n\n    if (obj.forEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length !== undefined$1) {\n      i = 0;\n\n      while (i < obj.length) {\n        iterator.call(context, obj[i], i, obj);\n        i++;\n      }\n    } else {\n      for (i in obj) {\n        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n      }\n    }\n  }\n  /**\n   * wrap a method with a deprecation warning and stack trace\n   * @param {Function} method\n   * @param {String} name\n   * @param {String} message\n   * @returns {Function} A new function wrapping the supplied method.\n   */\n\n\n  function deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function () {\n      var e = new Error('get-stack-trace');\n      var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n      var log = window.console && (window.console.warn || window.console.log);\n\n      if (log) {\n        log.call(window.console, deprecationMessage, stack);\n      }\n\n      return method.apply(this, arguments);\n    };\n  }\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} target\n   * @param {...Object} objects_to_assign\n   * @returns {Object} target\n   */\n\n\n  var assign;\n\n  if (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n      if (target === undefined$1 || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n\n      var output = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var source = arguments[index];\n\n        if (source !== undefined$1 && source !== null) {\n          for (var nextKey in source) {\n            if (source.hasOwnProperty(nextKey)) {\n              output[nextKey] = source[nextKey];\n            }\n          }\n        }\n      }\n\n      return output;\n    };\n  } else {\n    assign = Object.assign;\n  }\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} dest\n   * @param {Object} src\n   * @param {Boolean} [merge=false]\n   * @returns {Object} dest\n   */\n\n\n  var extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n\n    while (i < keys.length) {\n      if (!merge || merge && dest[keys[i]] === undefined$1) {\n        dest[keys[i]] = src[keys[i]];\n      }\n\n      i++;\n    }\n\n    return dest;\n  }, 'extend', 'Use `assign`.');\n  /**\n   * merge the values from src in the dest.\n   * means that properties that exist in dest will not be overwritten by src\n   * @param {Object} dest\n   * @param {Object} src\n   * @returns {Object} dest\n   */\n\n  var merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n  }, 'merge', 'Use `assign`.');\n  /**\n   * simple class inheritance\n   * @param {Function} child\n   * @param {Function} base\n   * @param {Object} [properties]\n   */\n\n  function inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n      assign(childP, properties);\n    }\n  }\n  /**\n   * simple function bind\n   * @param {Function} fn\n   * @param {Object} context\n   * @returns {Function}\n   */\n\n\n  function bindFn(fn, context) {\n    return function boundFn() {\n      return fn.apply(context, arguments);\n    };\n  }\n  /**\n   * let a boolean value also be a function that must return a boolean\n   * this first item in args will be used as the context\n   * @param {Boolean|Function} val\n   * @param {Array} [args]\n   * @returns {Boolean}\n   */\n\n\n  function boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n      return val.apply(args ? args[0] || undefined$1 : undefined$1, args);\n    }\n\n    return val;\n  }\n  /**\n   * use the val2 when val1 is undefined\n   * @param {*} val1\n   * @param {*} val2\n   * @returns {*}\n   */\n\n\n  function ifUndefined(val1, val2) {\n    return val1 === undefined$1 ? val2 : val1;\n  }\n  /**\n   * addEventListener with multiple events at once\n   * @param {EventTarget} target\n   * @param {String} types\n   * @param {Function} handler\n   */\n\n\n  function addEventListeners(target, types, handler) {\n    each(splitStr(types), function (type) {\n      target.addEventListener(type, handler, false);\n    });\n  }\n  /**\n   * removeEventListener with multiple events at once\n   * @param {EventTarget} target\n   * @param {String} types\n   * @param {Function} handler\n   */\n\n\n  function removeEventListeners(target, types, handler) {\n    each(splitStr(types), function (type) {\n      target.removeEventListener(type, handler, false);\n    });\n  }\n  /**\n   * find if a node is in the given parent\n   * @method hasParent\n   * @param {HTMLElement} node\n   * @param {HTMLElement} parent\n   * @return {Boolean} found\n   */\n\n\n  function hasParent(node, parent) {\n    while (node) {\n      if (node == parent) {\n        return true;\n      }\n\n      node = node.parentNode;\n    }\n\n    return false;\n  }\n  /**\n   * small indexOf wrapper\n   * @param {String} str\n   * @param {String} find\n   * @returns {Boolean} found\n   */\n\n\n  function inStr(str, find) {\n    return str.indexOf(find) > -1;\n  }\n  /**\n   * split string on whitespace\n   * @param {String} str\n   * @returns {Array} words\n   */\n\n\n  function splitStr(str) {\n    return str.trim().split(/\\s+/g);\n  }\n  /**\n   * find if a array contains the object using indexOf or a simple polyFill\n   * @param {Array} src\n   * @param {String} find\n   * @param {String} [findByKey]\n   * @return {Boolean|Number} false when not found, or the index\n   */\n\n\n  function inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n      return src.indexOf(find);\n    } else {\n      var i = 0;\n\n      while (i < src.length) {\n        if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n          return i;\n        }\n\n        i++;\n      }\n\n      return -1;\n    }\n  }\n  /**\n   * convert array-like objects to real arrays\n   * @param {Object} obj\n   * @returns {Array}\n   */\n\n\n  function toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n  }\n  /**\n   * unique array with objects based on a key (like 'id') or just by the array's value\n   * @param {Array} src [{id:1},{id:2},{id:1}]\n   * @param {String} [key]\n   * @param {Boolean} [sort=False]\n   * @returns {Array} [{id:1},{id:2}]\n   */\n\n\n  function uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n      var val = key ? src[i][key] : src[i];\n\n      if (inArray(values, val) < 0) {\n        results.push(src[i]);\n      }\n\n      values[i] = val;\n      i++;\n    }\n\n    if (sort) {\n      if (!key) {\n        results = results.sort();\n      } else {\n        results = results.sort(function sortUniqueArray(a, b) {\n          return a[key] > b[key];\n        });\n      }\n    }\n\n    return results;\n  }\n  /**\n   * get the prefixed property\n   * @param {Object} obj\n   * @param {String} property\n   * @returns {String|Undefined} prefixed\n   */\n\n\n  function prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n    var i = 0;\n\n    while (i < VENDOR_PREFIXES.length) {\n      prefix = VENDOR_PREFIXES[i];\n      prop = prefix ? prefix + camelProp : property;\n\n      if (prop in obj) {\n        return prop;\n      }\n\n      i++;\n    }\n\n    return undefined$1;\n  }\n  /**\n   * get a unique id\n   * @returns {number} uniqueId\n   */\n\n\n  var _uniqueId = 1;\n\n  function uniqueId() {\n    return _uniqueId++;\n  }\n  /**\n   * get the window object of an element\n   * @param {HTMLElement} element\n   * @returns {DocumentView|Window}\n   */\n\n\n  function getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return doc.defaultView || doc.parentWindow || window;\n  }\n\n  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n  var SUPPORT_TOUCH = 'ontouchstart' in window;\n  var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined$1;\n  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n  var INPUT_TYPE_TOUCH = 'touch';\n  var INPUT_TYPE_PEN = 'pen';\n  var INPUT_TYPE_MOUSE = 'mouse';\n  var INPUT_TYPE_KINECT = 'kinect';\n  var COMPUTE_INTERVAL = 25;\n  var INPUT_START = 1;\n  var INPUT_MOVE = 2;\n  var INPUT_END = 4;\n  var INPUT_CANCEL = 8;\n  var DIRECTION_NONE = 1;\n  var DIRECTION_LEFT = 2;\n  var DIRECTION_RIGHT = 4;\n  var DIRECTION_UP = 8;\n  var DIRECTION_DOWN = 16;\n  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n  var PROPS_XY = ['x', 'y'];\n  var PROPS_CLIENT_XY = ['clientX', 'clientY'];\n  /**\n   * create new input type manager\n   * @param {Manager} manager\n   * @param {Function} callback\n   * @returns {Input}\n   * @constructor\n   */\n\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n\n    this.domHandler = function (ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n\n    this.init();\n  }\n\n  Input.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function handler() {},\n\n    /**\n     * bind the events\n     */\n    init: function init() {\n      this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n      this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n      this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function destroy() {\n      this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n      this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n      this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n  };\n  /**\n   * create new input type manager\n   * called by the Manager constructor\n   * @param {Hammer} manager\n   * @returns {Input}\n   */\n\n  function createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n      Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n      Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n      Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n      Type = MouseInput;\n    } else {\n      Type = TouchMouseInput;\n    }\n\n    return new Type(manager, inputHandler);\n  }\n  /**\n   * handle input events\n   * @param {Manager} manager\n   * @param {String} eventType\n   * @param {Object} input\n   */\n\n\n  function inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n    var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n      manager.session = {};\n    } // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n\n\n    input.eventType = eventType; // compute scale, rotation etc\n\n    computeInputData(manager, input); // emit secret event\n\n    manager.emit('hammer.input', input);\n    manager.recognize(input);\n    manager.session.prevInput = input;\n  }\n  /**\n   * extend the data with some usable properties like scale, rotate, velocity etc\n   * @param {Object} manager\n   * @param {Object} input\n   */\n\n\n  function computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length; // store the first input to calculate the distance and direction\n\n    if (!session.firstInput) {\n      session.firstInput = simpleCloneInputData(input);\n    } // to compute scale and rotation we need to store the multiple touches\n\n\n    if (pointersLength > 1 && !session.firstMultiple) {\n      session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n      session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n    input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n    computeIntervalInputData(session, input); // find the correct target\n\n    var target = manager.element;\n\n    if (hasParent(input.srcEvent.target, target)) {\n      target = input.srcEvent.target;\n    }\n\n    input.target = target;\n  }\n\n  function computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n      prevDelta = session.prevDelta = {\n        x: prevInput.deltaX || 0,\n        y: prevInput.deltaY || 0\n      };\n      offset = session.offsetDelta = {\n        x: center.x,\n        y: center.y\n      };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n  }\n  /**\n   * velocity is calculated every x ms\n   * @param {Object} session\n   * @param {Object} input\n   */\n\n\n  function computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity,\n        velocityX,\n        velocityY,\n        direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined$1)) {\n      var deltaX = input.deltaX - last.deltaX;\n      var deltaY = input.deltaY - last.deltaY;\n      var v = getVelocity(deltaTime, deltaX, deltaY);\n      velocityX = v.x;\n      velocityY = v.y;\n      velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n      direction = getDirection(deltaX, deltaY);\n      session.lastInterval = input;\n    } else {\n      // use latest velocity info if it doesn't overtake a minimum period\n      velocity = last.velocity;\n      velocityX = last.velocityX;\n      velocityY = last.velocityY;\n      direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n  }\n  /**\n   * create a simple clone from the input used for storage of firstInput and firstMultiple\n   * @param {Object} input\n   * @returns {Object} clonedInputData\n   */\n\n\n  function simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n\n    while (i < input.pointers.length) {\n      pointers[i] = {\n        clientX: round(input.pointers[i].clientX),\n        clientY: round(input.pointers[i].clientY)\n      };\n      i++;\n    }\n\n    return {\n      timeStamp: now(),\n      pointers: pointers,\n      center: getCenter(pointers),\n      deltaX: input.deltaX,\n      deltaY: input.deltaY\n    };\n  }\n  /**\n   * get the center of all the pointers\n   * @param {Array} pointers\n   * @return {Object} center contains `x` and `y` properties\n   */\n\n\n  function getCenter(pointers) {\n    var pointersLength = pointers.length; // no need to loop when only one touch\n\n    if (pointersLength === 1) {\n      return {\n        x: round(pointers[0].clientX),\n        y: round(pointers[0].clientY)\n      };\n    }\n\n    var x = 0,\n        y = 0,\n        i = 0;\n\n    while (i < pointersLength) {\n      x += pointers[i].clientX;\n      y += pointers[i].clientY;\n      i++;\n    }\n\n    return {\n      x: round(x / pointersLength),\n      y: round(y / pointersLength)\n    };\n  }\n  /**\n   * calculate the velocity between two points. unit is in px per ms.\n   * @param {Number} deltaTime\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Object} velocity `x` and `y`\n   */\n\n\n  function getVelocity(deltaTime, x, y) {\n    return {\n      x: x / deltaTime || 0,\n      y: y / deltaTime || 0\n    };\n  }\n  /**\n   * get the direction between two points\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Number} direction\n   */\n\n\n  function getDirection(x, y) {\n    if (x === y) {\n      return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n      return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n  }\n  /**\n   * calculate the absolute distance between two points\n   * @param {Object} p1 {x, y}\n   * @param {Object} p2 {x, y}\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} distance\n   */\n\n\n  function getDistance(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.sqrt(x * x + y * y);\n  }\n  /**\n   * calculate the angle between two coordinates\n   * @param {Object} p1\n   * @param {Object} p2\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} angle\n   */\n\n\n  function getAngle(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n  }\n  /**\n   * calculate the rotation degrees between two pointersets\n   * @param {Array} start array of pointers\n   * @param {Array} end array of pointers\n   * @return {Number} rotation\n   */\n\n\n  function getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n  }\n  /**\n   * calculate the scale factor between two pointersets\n   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n   * @param {Array} start array of pointers\n   * @param {Array} end array of pointers\n   * @return {Number} scale\n   */\n\n\n  function getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n  }\n\n  var MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n  };\n  var MOUSE_ELEMENT_EVENTS = 'mousedown';\n  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n  /**\n   * Mouse events input\n   * @constructor\n   * @extends Input\n   */\n\n  function MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n  }\n\n  inherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n      var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down\n\n      if (eventType & INPUT_START && ev.button === 0) {\n        this.pressed = true;\n      }\n\n      if (eventType & INPUT_MOVE && ev.which !== 1) {\n        eventType = INPUT_END;\n      } // mouse must be down\n\n\n      if (!this.pressed) {\n        return;\n      }\n\n      if (eventType & INPUT_END) {\n        this.pressed = false;\n      }\n\n      this.callback(this.manager, eventType, {\n        pointers: [ev],\n        changedPointers: [ev],\n        pointerType: INPUT_TYPE_MOUSE,\n        srcEvent: ev\n      });\n    }\n  });\n  var POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n  }; // in IE10 the pointer types is defined as an enum\n\n  var IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n\n  };\n  var POINTER_ELEMENT_EVENTS = 'pointerdown';\n  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive\n\n  if (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n  }\n  /**\n   * Pointer events input\n   * @constructor\n   * @extends Input\n   */\n\n\n  function PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n    Input.apply(this, arguments);\n    this.store = this.manager.session.pointerEvents = [];\n  }\n\n  inherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n      var store = this.store;\n      var removePointer = false;\n      var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n      var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n      var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n      var isTouch = pointerType == INPUT_TYPE_TOUCH; // get index of the event in the store\n\n      var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down\n\n      if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n        if (storeIndex < 0) {\n          store.push(ev);\n          storeIndex = store.length - 1;\n        }\n      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        removePointer = true;\n      } // it not found, so the pointer hasn't been down (so it's probably a hover)\n\n\n      if (storeIndex < 0) {\n        return;\n      } // update the event in the store\n\n\n      store[storeIndex] = ev;\n      this.callback(this.manager, eventType, {\n        pointers: store,\n        changedPointers: [ev],\n        pointerType: pointerType,\n        srcEvent: ev\n      });\n\n      if (removePointer) {\n        // remove from the store\n        store.splice(storeIndex, 1);\n      }\n    }\n  });\n  var SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n  };\n  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\n  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n  /**\n   * Touch events input\n   * @constructor\n   * @extends Input\n   */\n\n  function SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n    Input.apply(this, arguments);\n  }\n\n  inherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n      var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?\n\n      if (type === INPUT_START) {\n        this.started = true;\n      }\n\n      if (!this.started) {\n        return;\n      }\n\n      var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state\n\n      if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n        this.started = false;\n      }\n\n      this.callback(this.manager, type, {\n        pointers: touches[0],\n        changedPointers: touches[1],\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  });\n  /**\n   * @this {TouchInput}\n   * @param {Object} ev\n   * @param {Number} type flag\n   * @returns {undefined|Array} [all, changed]\n   */\n\n  function normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n  }\n\n  var TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n  };\n  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n  /**\n   * Multi-user touch events input\n   * @constructor\n   * @extends Input\n   */\n\n  function TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n    Input.apply(this, arguments);\n  }\n\n  inherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n      var type = TOUCH_INPUT_MAP[ev.type];\n      var touches = getTouches.call(this, ev, type);\n\n      if (!touches) {\n        return;\n      }\n\n      this.callback(this.manager, type, {\n        pointers: touches[0],\n        changedPointers: touches[1],\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  });\n  /**\n   * @this {TouchInput}\n   * @param {Object} ev\n   * @param {Number} type flag\n   * @returns {undefined|Array} [all, changed]\n   */\n\n  function getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds; // when there is only one touch, the process can be simplified\n\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n      targetIds[allTouches[0].identifier] = true;\n      return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target; // get target touches from touches\n\n    targetTouches = allTouches.filter(function (touch) {\n      return hasParent(touch.target, target);\n    }); // collect touches\n\n    if (type === INPUT_START) {\n      i = 0;\n\n      while (i < targetTouches.length) {\n        targetIds[targetTouches[i].identifier] = true;\n        i++;\n      }\n    } // filter changed touches to only contain touches that exist in the collected target ids\n\n\n    i = 0;\n\n    while (i < changedTouches.length) {\n      if (targetIds[changedTouches[i].identifier]) {\n        changedTargetTouches.push(changedTouches[i]);\n      } // cleanup removed touches\n\n\n      if (type & (INPUT_END | INPUT_CANCEL)) {\n        delete targetIds[changedTouches[i].identifier];\n      }\n\n      i++;\n    }\n\n    if (!changedTargetTouches.length) {\n      return;\n    }\n\n    return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n  }\n  /**\n   * Combined touch and mouse input\n   *\n   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n   * This because touch devices also emit mouse events while doing a touch.\n   *\n   * @constructor\n   * @extends Input\n   */\n\n\n  var DEDUP_TIMEOUT = 2500;\n  var DEDUP_DISTANCE = 25;\n\n  function TouchMouseInput() {\n    Input.apply(this, arguments);\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n    this.primaryTouch = null;\n    this.lastTouches = [];\n  }\n\n  inherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n      var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,\n          isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;\n\n      if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n        return;\n      } // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n\n\n      if (isTouch) {\n        recordTouches.call(this, inputEvent, inputData);\n      } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n        return;\n      }\n\n      this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    }\n  });\n\n  function recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n      this.primaryTouch = eventData.changedPointers[0].identifier;\n      setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      setLastTouch.call(this, eventData);\n    }\n  }\n\n  function setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n\n    if (touch.identifier === this.primaryTouch) {\n      var lastTouch = {\n        x: touch.clientX,\n        y: touch.clientY\n      };\n      this.lastTouches.push(lastTouch);\n      var lts = this.lastTouches;\n\n      var removeLastTouch = function removeLastTouch() {\n        var i = lts.indexOf(lastTouch);\n\n        if (i > -1) {\n          lts.splice(i, 1);\n        }\n      };\n\n      setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n  }\n\n  function isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX,\n        y = eventData.srcEvent.clientY;\n\n    for (var i = 0; i < this.lastTouches.length; i++) {\n      var t = this.lastTouches[i];\n      var dx = Math.abs(x - t.x),\n          dy = Math.abs(y - t.y);\n\n      if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\n  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined$1; // magical touchAction value\n\n  var TOUCH_ACTION_COMPUTE = 'compute';\n  var TOUCH_ACTION_AUTO = 'auto';\n  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n\n  var TOUCH_ACTION_NONE = 'none';\n  var TOUCH_ACTION_PAN_X = 'pan-x';\n  var TOUCH_ACTION_PAN_Y = 'pan-y';\n  var TOUCH_ACTION_MAP = getTouchActionProps();\n  /**\n   * Touch Action\n   * sets the touchAction property or uses the js alternative\n   * @param {Manager} manager\n   * @param {String} value\n   * @constructor\n   */\n\n  function TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n\n  TouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function set(value) {\n      // find out the touch-action by the event handlers\n      if (value == TOUCH_ACTION_COMPUTE) {\n        value = this.compute();\n      }\n\n      if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n      }\n\n      this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function update() {\n      this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function compute() {\n      var actions = [];\n      each(this.manager.recognizers, function (recognizer) {\n        if (boolOrFn(recognizer.options.enable, [recognizer])) {\n          actions = actions.concat(recognizer.getTouchAction());\n        }\n      });\n      return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function preventDefaults(input) {\n      var srcEvent = input.srcEvent;\n      var direction = input.offsetDirection; // if the touch action did prevented once this session\n\n      if (this.manager.session.prevented) {\n        srcEvent.preventDefault();\n        return;\n      }\n\n      var actions = this.actions;\n      var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n      if (hasNone) {\n        //do not prevent defaults if this is a tap gesture\n        var isTapPointer = input.pointers.length === 1;\n        var isTapMovement = input.distance < 2;\n        var isTapTouchTime = input.deltaTime < 250;\n\n        if (isTapPointer && isTapMovement && isTapTouchTime) {\n          return;\n        }\n      }\n\n      if (hasPanX && hasPanY) {\n        // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n        return;\n      }\n\n      if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n        return this.preventSrc(srcEvent);\n      }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function preventSrc(srcEvent) {\n      this.manager.session.prevented = true;\n      srcEvent.preventDefault();\n    }\n  };\n  /**\n   * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n   * @param {String} actions\n   * @returns {*}\n   */\n\n  function cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n      return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n\n    if (hasPanX && hasPanY) {\n      return TOUCH_ACTION_NONE;\n    } // pan-x OR pan-y\n\n\n    if (hasPanX || hasPanY) {\n      return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    } // manipulation\n\n\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n      return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n  }\n\n  function getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n      return false;\n    }\n\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n      // If css.supports is not supported but there is native touch-action assume it supports\n      // all values. This is the case for IE 10 and 11.\n      touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n  }\n  /**\n   * Recognizer flow explained; *\n   * All recognizers have the initial state of POSSIBLE when a input session starts.\n   * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n   * Example session for mouse-input: mousedown -> mousemove -> mouseup\n   *\n   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n   * which determines with state it should be.\n   *\n   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n   * POSSIBLE to give it another change on the next cycle.\n   *\n   *               Possible\n   *                  |\n   *            +-----+---------------+\n   *            |                     |\n   *      +-----+-----+               |\n   *      |           |               |\n   *   Failed      Cancelled          |\n   *                          +-------+------+\n   *                          |              |\n   *                      Recognized       Began\n   *                                         |\n   *                                      Changed\n   *                                         |\n   *                                  Ended/Recognized\n   */\n\n\n  var STATE_POSSIBLE = 1;\n  var STATE_BEGAN = 2;\n  var STATE_CHANGED = 4;\n  var STATE_ENDED = 8;\n  var STATE_RECOGNIZED = STATE_ENDED;\n  var STATE_CANCELLED = 16;\n  var STATE_FAILED = 32;\n  /**\n   * Recognizer\n   * Every recognizer needs to extend from this class.\n   * @constructor\n   * @param {Object} options\n   */\n\n  function Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n    this.id = uniqueId();\n    this.manager = null; // default is enable true\n\n    this.options.enable = ifUndefined(this.options.enable, true);\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n\n  Recognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function set(options) {\n      assign(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state\n\n      this.manager && this.manager.touchAction.update();\n      return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function recognizeWith(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n        return this;\n      }\n\n      var simultaneous = this.simultaneous;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n      if (!simultaneous[otherRecognizer.id]) {\n        simultaneous[otherRecognizer.id] = otherRecognizer;\n        otherRecognizer.recognizeWith(this);\n      }\n\n      return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function dropRecognizeWith(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n        return this;\n      }\n\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      delete this.simultaneous[otherRecognizer.id];\n      return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function requireFailure(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n        return this;\n      }\n\n      var requireFail = this.requireFail;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n      if (inArray(requireFail, otherRecognizer) === -1) {\n        requireFail.push(otherRecognizer);\n        otherRecognizer.requireFailure(this);\n      }\n\n      return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function dropRequireFailure(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n        return this;\n      }\n\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      var index = inArray(this.requireFail, otherRecognizer);\n\n      if (index > -1) {\n        this.requireFail.splice(index, 1);\n      }\n\n      return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function hasRequireFailures() {\n      return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function canRecognizeWith(otherRecognizer) {\n      return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function emit(input) {\n      var self = this;\n      var state = this.state;\n\n      function emit(event) {\n        self.manager.emit(event, input);\n      } // 'panstart' and 'panmove'\n\n\n      if (state < STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n\n      emit(self.options.event); // simple 'eventName' events\n\n      if (input.additionalEvent) {\n        // additional event(panleft, panright, pinchin, pinchout...)\n        emit(input.additionalEvent);\n      } // panend and pancancel\n\n\n      if (state >= STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function tryEmit(input) {\n      if (this.canEmit()) {\n        return this.emit(input);\n      } // it's failing anyway\n\n\n      this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function canEmit() {\n      var i = 0;\n\n      while (i < this.requireFail.length) {\n        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n          return false;\n        }\n\n        i++;\n      }\n\n      return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function recognize(inputData) {\n      // make a new copy of the inputData\n      // so we can change the inputData without messing up the other recognizers\n      var inputDataClone = assign({}, inputData); // is is enabled and allow recognizing?\n\n      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n        this.reset();\n        this.state = STATE_FAILED;\n        return;\n      } // reset when we've reached the end\n\n\n      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n        this.state = STATE_POSSIBLE;\n      }\n\n      this.state = this.process(inputDataClone); // the recognizer has recognized a gesture\n      // so trigger an event\n\n      if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n        this.tryEmit(inputDataClone);\n      }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function process(inputData) {},\n    // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function getTouchAction() {},\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function reset() {}\n  };\n  /**\n   * get a usable string, used as event postfix\n   * @param {Const} state\n   * @returns {String} state\n   */\n\n  function stateStr(state) {\n    if (state & STATE_CANCELLED) {\n      return 'cancel';\n    } else if (state & STATE_ENDED) {\n      return 'end';\n    } else if (state & STATE_CHANGED) {\n      return 'move';\n    } else if (state & STATE_BEGAN) {\n      return 'start';\n    }\n\n    return '';\n  }\n  /**\n   * direction cons to string\n   * @param {Const} direction\n   * @returns {String}\n   */\n\n\n  function directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n      return 'down';\n    } else if (direction == DIRECTION_UP) {\n      return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n      return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n      return 'right';\n    }\n\n    return '';\n  }\n  /**\n   * get a recognizer by name if it is bound to a manager\n   * @param {Recognizer|String} otherRecognizer\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer}\n   */\n\n\n  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n\n    if (manager) {\n      return manager.get(otherRecognizer);\n    }\n\n    return otherRecognizer;\n  }\n  /**\n   * This recognizer is just used as a base for the simple attribute recognizers.\n   * @constructor\n   * @extends Recognizer\n   */\n\n\n  function AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n  }\n\n  inherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n      /**\n       * @type {Number}\n       * @default 1\n       */\n      pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function attrTest(input) {\n      var optionPointers = this.options.pointers;\n      return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function process(input) {\n      var state = this.state;\n      var eventType = input.eventType;\n      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n      var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED\n\n      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n        return state | STATE_CANCELLED;\n      } else if (isRecognized || isValid) {\n        if (eventType & INPUT_END) {\n          return state | STATE_ENDED;\n        } else if (!(state & STATE_BEGAN)) {\n          return STATE_BEGAN;\n        }\n\n        return state | STATE_CHANGED;\n      }\n\n      return STATE_FAILED;\n    }\n  });\n  /**\n   * Pan\n   * Recognized when the pointer is down and moved in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n\n  function PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n    this.pX = null;\n    this.pY = null;\n  }\n\n  inherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    },\n    getTouchAction: function getTouchAction() {\n      var direction = this.options.direction;\n      var actions = [];\n\n      if (direction & DIRECTION_HORIZONTAL) {\n        actions.push(TOUCH_ACTION_PAN_Y);\n      }\n\n      if (direction & DIRECTION_VERTICAL) {\n        actions.push(TOUCH_ACTION_PAN_X);\n      }\n\n      return actions;\n    },\n    directionTest: function directionTest(input) {\n      var options = this.options;\n      var hasMoved = true;\n      var distance = input.distance;\n      var direction = input.direction;\n      var x = input.deltaX;\n      var y = input.deltaY; // lock to axis?\n\n      if (!(direction & options.direction)) {\n        if (options.direction & DIRECTION_HORIZONTAL) {\n          direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n          hasMoved = x != this.pX;\n          distance = Math.abs(input.deltaX);\n        } else {\n          direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n          hasMoved = y != this.pY;\n          distance = Math.abs(input.deltaY);\n        }\n      }\n\n      input.direction = direction;\n      return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n    attrTest: function attrTest(input) {\n      return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n    },\n    emit: function emit(input) {\n      this.pX = input.deltaX;\n      this.pY = input.deltaY;\n      var direction = directionStr(input.direction);\n\n      if (direction) {\n        input.additionalEvent = this.options.event + direction;\n      }\n\n      this._super.emit.call(this, input);\n    }\n  });\n  /**\n   * Pinch\n   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n   * @constructor\n   * @extends AttrRecognizer\n   */\n\n  function PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function getTouchAction() {\n      return [TOUCH_ACTION_NONE];\n    },\n    attrTest: function attrTest(input) {\n      return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n    emit: function emit(input) {\n      if (input.scale !== 1) {\n        var inOut = input.scale < 1 ? 'in' : 'out';\n        input.additionalEvent = this.options.event + inOut;\n      }\n\n      this._super.emit.call(this, input);\n    }\n  });\n  /**\n   * Press\n   * Recognized when the pointer is down for x ms without any movement.\n   * @constructor\n   * @extends Recognizer\n   */\n\n  function PressRecognizer() {\n    Recognizer.apply(this, arguments);\n    this._timer = null;\n    this._input = null;\n  }\n\n  inherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      // minimal time of the pointer to be pressed\n      threshold: 9 // a minimal movement is ok, but keep it low\n\n    },\n    getTouchAction: function getTouchAction() {\n      return [TOUCH_ACTION_AUTO];\n    },\n    process: function process(input) {\n      var options = this.options;\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTime = input.deltaTime > options.time;\n      this._input = input; // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n\n      if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n        this.reset();\n      } else if (input.eventType & INPUT_START) {\n        this.reset();\n        this._timer = setTimeoutContext(function () {\n          this.state = STATE_RECOGNIZED;\n          this.tryEmit();\n        }, options.time, this);\n      } else if (input.eventType & INPUT_END) {\n        return STATE_RECOGNIZED;\n      }\n\n      return STATE_FAILED;\n    },\n    reset: function reset() {\n      clearTimeout(this._timer);\n    },\n    emit: function emit(input) {\n      if (this.state !== STATE_RECOGNIZED) {\n        return;\n      }\n\n      if (input && input.eventType & INPUT_END) {\n        this.manager.emit(this.options.event + 'up', input);\n      } else {\n        this._input.timeStamp = now();\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n  /**\n   * Rotate\n   * Recognized when two or more pointer are moving in a circular motion.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n\n  function RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function getTouchAction() {\n      return [TOUCH_ACTION_NONE];\n    },\n    attrTest: function attrTest(input) {\n      return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n  });\n  /**\n   * Swipe\n   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n\n  function SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    },\n    getTouchAction: function getTouchAction() {\n      return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n    attrTest: function attrTest(input) {\n      var direction = this.options.direction;\n      var velocity;\n\n      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n        velocity = input.overallVelocity;\n      } else if (direction & DIRECTION_HORIZONTAL) {\n        velocity = input.overallVelocityX;\n      } else if (direction & DIRECTION_VERTICAL) {\n        velocity = input.overallVelocityY;\n      }\n\n      return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n    emit: function emit(input) {\n      var direction = directionStr(input.offsetDirection);\n\n      if (direction) {\n        this.manager.emit(this.options.event + direction, input);\n      }\n\n      this.manager.emit(this.options.event, input);\n    }\n  });\n  /**\n   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n   * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n   * a single tap.\n   *\n   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n   * multi-taps being recognized.\n   * @constructor\n   * @extends Recognizer\n   */\n\n  function TapRecognizer() {\n    Recognizer.apply(this, arguments); // previous time and center,\n    // used for tap counting\n\n    this.pTime = false;\n    this.pCenter = false;\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n  }\n\n  inherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      // max time between the multi-tap taps\n      time: 250,\n      // max time of the pointer to be down (like finger on the screen)\n      threshold: 9,\n      // a minimal movement is ok, but keep it low\n      posThreshold: 10 // a multi-tap can be a bit off the initial position\n\n    },\n    getTouchAction: function getTouchAction() {\n      return [TOUCH_ACTION_MANIPULATION];\n    },\n    process: function process(input) {\n      var options = this.options;\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTouchTime = input.deltaTime < options.time;\n      this.reset();\n\n      if (input.eventType & INPUT_START && this.count === 0) {\n        return this.failTimeout();\n      } // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n\n\n      if (validMovement && validTouchTime && validPointers) {\n        if (input.eventType != INPUT_END) {\n          return this.failTimeout();\n        }\n\n        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n        this.pTime = input.timeStamp;\n        this.pCenter = input.center;\n\n        if (!validMultiTap || !validInterval) {\n          this.count = 1;\n        } else {\n          this.count += 1;\n        }\n\n        this._input = input; // if tap count matches we have recognized it,\n        // else it has began recognizing...\n\n        var tapCount = this.count % options.taps;\n\n        if (tapCount === 0) {\n          // no failing requirements, immediately trigger the tap event\n          // or wait as long as the multitap interval to trigger\n          if (!this.hasRequireFailures()) {\n            return STATE_RECOGNIZED;\n          } else {\n            this._timer = setTimeoutContext(function () {\n              this.state = STATE_RECOGNIZED;\n              this.tryEmit();\n            }, options.interval, this);\n            return STATE_BEGAN;\n          }\n        }\n      }\n\n      return STATE_FAILED;\n    },\n    failTimeout: function failTimeout() {\n      this._timer = setTimeoutContext(function () {\n        this.state = STATE_FAILED;\n      }, this.options.interval, this);\n      return STATE_FAILED;\n    },\n    reset: function reset() {\n      clearTimeout(this._timer);\n    },\n    emit: function emit() {\n      if (this.state == STATE_RECOGNIZED) {\n        this._input.tapCount = this.count;\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n  /**\n   * Simple way to create a manager with a default set of recognizers.\n   * @param {HTMLElement} element\n   * @param {Object} [options]\n   * @constructor\n   */\n\n  function Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n  }\n  /**\n   * @const {string}\n   */\n\n\n  Hammer.VERSION = '2.0.7';\n  /**\n   * default settings\n   * @namespace\n   */\n\n  Hammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [// RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n    [RotateRecognizer, {\n      enable: false\n    }], [PinchRecognizer, {\n      enable: false\n    }, ['rotate']], [SwipeRecognizer, {\n      direction: DIRECTION_HORIZONTAL\n    }], [PanRecognizer, {\n      direction: DIRECTION_HORIZONTAL\n    }, ['swipe']], [TapRecognizer], [TapRecognizer, {\n      event: 'doubletap',\n      taps: 2\n    }, ['tap']], [PressRecognizer]],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n      /**\n       * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n       * @type {String}\n       * @default 'none'\n       */\n      userSelect: 'none',\n\n      /**\n       * Disable the Windows Phone grippers when pressing an element.\n       * @type {String}\n       * @default 'none'\n       */\n      touchSelect: 'none',\n\n      /**\n       * Disables the default callout shown when you touch and hold a touch target.\n       * On iOS, when you touch and hold a touch target such as a link, Safari displays\n       * a callout containing information about the link. This property allows you to disable that callout.\n       * @type {String}\n       * @default 'none'\n       */\n      touchCallout: 'none',\n\n      /**\n       * Specifies whether zooming is enabled. Used by IE10>\n       * @type {String}\n       * @default 'none'\n       */\n      contentZooming: 'none',\n\n      /**\n       * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n       * @type {String}\n       * @default 'none'\n       */\n      userDrag: 'none',\n\n      /**\n       * Overrides the highlight color shown when the user taps a link or a JavaScript\n       * clickable element in iOS. This property obeys the alpha value, if specified.\n       * @type {String}\n       * @default 'rgba(0,0,0,0)'\n       */\n      tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n  };\n  var STOP = 1;\n  var FORCED_STOP = 2;\n  /**\n   * Manager\n   * @param {HTMLElement} element\n   * @param {Object} [options]\n   * @constructor\n   */\n\n  function Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    toggleCssProps(this, true);\n    each(this.options.recognizers, function (item) {\n      var recognizer = this.add(new item[0](item[1]));\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n\n  Manager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function set(options) {\n      assign(this.options, options); // Options that need a little more setup\n\n      if (options.touchAction) {\n        this.touchAction.update();\n      }\n\n      if (options.inputTarget) {\n        // Clean up existing event listeners and reinitialize\n        this.input.destroy();\n        this.input.target = options.inputTarget;\n        this.input.init();\n      }\n\n      return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function stop(force) {\n      this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function recognize(inputData) {\n      var session = this.session;\n\n      if (session.stopped) {\n        return;\n      } // run the touch-action polyfill\n\n\n      this.touchAction.preventDefaults(inputData);\n      var recognizer;\n      var recognizers = this.recognizers; // this holds the recognizer that is being recognized.\n      // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n      // if no recognizer is detecting a thing, it is set to `null`\n\n      var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized\n      // or when we're in a new session\n\n      if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n        curRecognizer = session.curRecognizer = null;\n      }\n\n      var i = 0;\n\n      while (i < recognizers.length) {\n        recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.\n        // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n        //      that is being recognized.\n        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n        //      this can be setup with the `recognizeWith()` method on the recognizer.\n\n        if (session.stopped !== FORCED_STOP && ( // 1\n        !curRecognizer || recognizer == curRecognizer || // 2\n        recognizer.canRecognizeWith(curRecognizer))) {\n          // 3\n          recognizer.recognize(inputData);\n        } else {\n          recognizer.reset();\n        } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n        // current active recognizer. but only if we don't already have an active recognizer\n\n\n        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n          curRecognizer = session.curRecognizer = recognizer;\n        }\n\n        i++;\n      }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function get(recognizer) {\n      if (recognizer instanceof Recognizer) {\n        return recognizer;\n      }\n\n      var recognizers = this.recognizers;\n\n      for (var i = 0; i < recognizers.length; i++) {\n        if (recognizers[i].options.event == recognizer) {\n          return recognizers[i];\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function add(recognizer) {\n      if (invokeArrayArg(recognizer, 'add', this)) {\n        return this;\n      } // remove existing\n\n\n      var existing = this.get(recognizer.options.event);\n\n      if (existing) {\n        this.remove(existing);\n      }\n\n      this.recognizers.push(recognizer);\n      recognizer.manager = this;\n      this.touchAction.update();\n      return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function remove(recognizer) {\n      if (invokeArrayArg(recognizer, 'remove', this)) {\n        return this;\n      }\n\n      recognizer = this.get(recognizer); // let's make sure this recognizer exists\n\n      if (recognizer) {\n        var recognizers = this.recognizers;\n        var index = inArray(recognizers, recognizer);\n\n        if (index !== -1) {\n          recognizers.splice(index, 1);\n          this.touchAction.update();\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function on(events, handler) {\n      if (events === undefined$1) {\n        return;\n      }\n\n      if (handler === undefined$1) {\n        return;\n      }\n\n      var handlers = this.handlers;\n      each(splitStr(events), function (event) {\n        handlers[event] = handlers[event] || [];\n        handlers[event].push(handler);\n      });\n      return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function off(events, handler) {\n      if (events === undefined$1) {\n        return;\n      }\n\n      var handlers = this.handlers;\n      each(splitStr(events), function (event) {\n        if (!handler) {\n          delete handlers[event];\n        } else {\n          handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n        }\n      });\n      return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function emit(event, data) {\n      // we also want to trigger dom events\n      if (this.options.domEvents) {\n        triggerDomEvent(event, data);\n      } // no handlers, so skip it all\n\n\n      var handlers = this.handlers[event] && this.handlers[event].slice();\n\n      if (!handlers || !handlers.length) {\n        return;\n      }\n\n      data.type = event;\n\n      data.preventDefault = function () {\n        data.srcEvent.preventDefault();\n      };\n\n      var i = 0;\n\n      while (i < handlers.length) {\n        handlers[i](data);\n        i++;\n      }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function destroy() {\n      this.element && toggleCssProps(this, false);\n      this.handlers = {};\n      this.session = {};\n      this.input.destroy();\n      this.element = null;\n    }\n  };\n  /**\n   * add/remove the css properties as defined in manager.options.cssProps\n   * @param {Manager} manager\n   * @param {Boolean} add\n   */\n\n  function toggleCssProps(manager, add) {\n    var element = manager.element;\n\n    if (!element.style) {\n      return;\n    }\n\n    var prop;\n    each(manager.options.cssProps, function (value, name) {\n      prop = prefixed(element.style, name);\n\n      if (add) {\n        manager.oldCssProps[prop] = element.style[prop];\n        element.style[prop] = value;\n      } else {\n        element.style[prop] = manager.oldCssProps[prop] || '';\n      }\n    });\n\n    if (!add) {\n      manager.oldCssProps = {};\n    }\n  }\n  /**\n   * trigger dom event\n   * @param {String} event\n   * @param {Object} data\n   */\n\n\n  function triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n  }\n\n  assign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n  }); // this prevents errors when Hammer is loaded in the presence of an AMD\n  //  style loader but by script tag, not by the loader.\n\n  var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line\n\n  freeGlobal.Hammer = Hammer;\n\n  if (typeof undefined$1 === 'function' && undefined$1.amd) {\n    undefined$1(function () {\n      return Hammer;\n    });\n  } else if (module.exports) {\n    module.exports = Hammer;\n  } else {\n    window[exportName] = Hammer;\n  }\n})(window, document, 'Hammer');\n});\n\nconst DEFAULT_DURATION = 160;\nconst DEFAULT_CANCEL_DRAG_FACTOR = 1 / 5;\nconst DEFAULT_GROUP_SIZE = 1;\nconst DEFAULT_ORIENTATION = \"vertical\";\nconst DEFAULT_DIRECTION = 1;\nconst DEFAULT_OFFSET_X = 0;\nconst DEFAULT_OFFSET_Y = 0;\n\nconst Touch = (_ref) => {\n  let el = _ref.el,\n      orientation = _ref.orientation;\n  const hammer = new Hammer.Manager(el, {});\n  hammer.add(new Hammer.Pan({\n    direction: orientation === \"vertical\" ? Hammer.DIRECTION_VERTICAL : orientation === \"all\" ? Hammer.DIRECTION_ALL : Hammer.DIRECTION_HORIZONTAL,\n    threshold: 0\n  }));\n  return hammer;\n};\n\nconst Actions = update => ({\n  setIndex: newIndex => update({\n    index: newIndex\n  }),\n  setList: newList => update({\n    list: newList\n  }),\n  setGroupBy: value => update({\n    groupBy: value\n  }),\n  setPageSize: value => update({\n    pageSize: value\n  })\n});\n\nconst _Slider = (_ref2) => {\n  let h = _ref2.h,\n      useReducer = _ref2.useReducer,\n      useState = _ref2.useState,\n      useEffect = _ref2.useEffect,\n      useRef = _ref2.useRef,\n      getRef = _ref2.getRef,\n      props = _objectWithoutProperties(_ref2, [\"h\", \"useReducer\", \"useState\", \"useEffect\", \"useRef\", \"getRef\"]);\n\n  const _useReducer = useReducer(O, {\n    index: props.index || -1,\n    list: [],\n    groupBy: props.groupBy || DEFAULT_GROUP_SIZE,\n    pageSize: 0\n  }),\n        _useReducer2 = _slicedToArray(_useReducer, 2),\n        state = _useReducer2[0],\n        update = _useReducer2[1];\n\n  const actionsRef = useRef(Actions(update));\n  const actions = actionsRef.current;\n  console.log(\"state\", state);\n  debugger;\n\n  const _useState = useState(),\n        _useState2 = _slicedToArray(_useState, 2),\n        domElement = _useState2[0],\n        setDomElement = _useState2[1];\n\n  const _useState3 = useState(),\n        _useState4 = _slicedToArray(_useState3, 2),\n        contentElement = _useState4[0],\n        setContentElement = _useState4[1];\n\n  const touchRef = useRef(); // Reference to HammerJS instance\n\n  const _index = state.index;\n  const list = state.list;\n  const groupBy = state.groupBy;\n  const pageSize = state.pageSize;\n  const contentChildLength = contentElement ? contentElement.childNodes.length : 0;\n  const duration = parseInt(props.duration, 10) || DEFAULT_DURATION;\n  const cancelDragFactor = props.cancelDragFactor || DEFAULT_CANCEL_DRAG_FACTOR;\n  const isVertical = props.orientation === DEFAULT_ORIENTATION;\n  const dir = props.rtl ? -1 : DEFAULT_DIRECTION;\n  const pageOffsetX = props.pageOffsetX || DEFAULT_OFFSET_X;\n  const pageOffsetY = props.pageOffsetY || DEFAULT_OFFSET_Y;\n\n  const hasPrevious = () => _index > 0;\n\n  const hasNext = () => _index + groupBy < list.length;\n\n  const getPageElement = (el, index) => el.childNodes[index];\n\n  const updateIndex = newIndex => {\n    const oldIndex = _index;\n\n    if (oldIndex !== newIndex) {\n      actions.setIndex(newIndex);\n\n      if (props.getState) {\n        const el = contentElement;\n        const page = getPageElement(el, _index);\n        props.getState({\n          index: newIndex,\n          hasNext: hasNext(),\n          hasPrevious: hasPrevious(),\n          pageElement: page\n        });\n      }\n    }\n  };\n\n  const createStyleProps = value => {\n    const x = isVertical ? \"0\" : value + \"px\";\n    const y = isVertical ? value + \"px\" : \"0\";\n    const z = \"0\";\n    const attrs = [x, y, z].join(\", \");\n    return \"translate3d(\" + attrs + \")\";\n  };\n\n  const setTransitionStyle = (el, value) => {\n    const style = el.style;\n    style.transform = style[\"-webkit-transform\"] = style[\"-moz-transform\"] = style[\"-ms-transform\"] = createStyleProps(value);\n  };\n\n  const setTransitionDurationStyle = duration => {\n    contentElement.style[\"-webkit-transition-duration\"] = contentElement.style[\"transition-duration\"] = duration + \"ms\";\n  };\n\n  const goTo = (idx, duration) => {\n    if (idx < 0 || idx > list.length - 1) {\n      return;\n    }\n\n    updateContentSize(contentElement);\n\n    if (duration !== undefined) {\n      setTransitionDurationStyle(duration);\n    }\n\n    updateIndex(idx); // console.log(\"goTo\", idx, \"pageSize\", pageSize, -dir * idx * pageSize);\n\n    setTransitionStyle(contentElement, -dir * idx * pageSize);\n  };\n\n  const getNormalizedStep = function getNormalizedStep() {\n    let orientation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    const idx = _index;\n    const size = groupBy;\n    const min = 0;\n    const max = list.length;\n    const next = idx + orientation * size; // make sure that last item aligns at the right\n\n    if (next + size > max) {\n      return max - size;\n    }\n\n    if (next < min) {\n      return min;\n    }\n\n    return next;\n  };\n\n  const updateContentSize = el => {\n    const prop = isVertical ? \"height\" : \"width\";\n    const page = el.childNodes[0];\n\n    if (!page) {\n      return;\n    }\n\n    if (page.getBoundingClientRect()[prop]) {\n      const newPageSize = page.getBoundingClientRect()[prop]; // console.log(\"updateContentSize\", \"pageSize\", pageSize);\n\n      if (newPageSize !== pageSize) {\n        actions.setPageSize(newPageSize);\n      }\n\n      el.style[prop] = list.length * pageSize + \"px\";\n    }\n  };\n\n  const goCurrent = function goCurrent() {\n    let duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    // updateContentSize(contentElement);\n    setTransitionDurationStyle(duration);\n    goTo(getNormalizedStep());\n  };\n\n  const goNext = function goNext() {\n    let dur = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : duration;\n    return setTransitionDurationStyle(dur), _index < list.length ? goTo(getNormalizedStep(1)) : goTo(getNormalizedStep());\n  };\n\n  const goPrevious = function goPrevious() {\n    let dur = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : duration;\n    return setTransitionDurationStyle(dur), _index > 0 ? goTo(getNormalizedStep(-1)) : goTo(getNormalizedStep());\n  };\n\n  const updateContentElement = el => {\n    setContentElement(el);\n    updateContentSize(el);\n    goCurrent();\n  };\n\n  const handleDragStart = () => (updateContentSize(contentElement), setTransitionDurationStyle(0));\n\n  const handleDrag = e => {\n    e.preventDefault();\n    const el = contentElement;\n    const page = getPageElement(el, _index);\n\n    if (!page) {\n      return;\n    }\n\n    const delta = isVertical ? e.deltaY + pageOffsetY : e.deltaX + pageOffsetX;\n    const origin = isVertical ? page.offsetTop : dir === -1 ? page.offsetLeft - page.parentNode.clientWidth + page.clientWidth : page.offsetLeft;\n    setTransitionStyle(el, delta - origin);\n  };\n\n  const handleDragEnd = e => {\n    const dur = calculateTransitionDuration(e.velocity);\n    const delta = isVertical ? e.deltaY : e.deltaX;\n\n    if (Math.abs(delta) > pageSize * groupBy * cancelDragFactor) {\n      if (dir * delta < 0) {\n        goNext(dur);\n      } else {\n        goPrevious(dur);\n      }\n    } else {\n      goCurrent(dur);\n    }\n  };\n\n  const calculateTransitionDuration = velocity => {\n    const el = contentElement;\n    const page = getPageElement(el, _index);\n\n    if (!page) {\n      return;\n    }\n\n    const width = page.clientWidth;\n    const speed = Math.abs(velocity) || 1;\n    let dur = 1 / speed * width;\n\n    if (dur > duration) {\n      dur = duration;\n    }\n\n    return dur;\n  }; // Populate list (on mount)\n\n\n  useEffect(() => {\n    if (!domElement) {\n      return;\n    }\n\n    if (props.pageData) {\n      props.pageData().then(result => actions.setList(result));\n    }\n\n    setContentElement(domElement.querySelector(\".\".concat(classes.content)));\n  }, [domElement]); // Init HammerJS\n\n  useEffect(() => {\n    if (contentChildLength == 0) {\n      return;\n    }\n\n    updateContentElement(contentElement);\n    updateContentSize(contentElement);\n    touchRef.current = new Touch({\n      el: contentElement,\n      orientation: props.orientation\n    });\n  }, [contentChildLength]); // Update touch lib events\n\n  useEffect(() => {\n    if (!touchRef.current) {\n      return;\n    } // touchRef.current.off(\"panstart\", handleDragStart);\n    // touchRef.current.off(\"panmove\", handleDrag);\n    // touchRef.current.off(\"panend\", handleDragEnd);\n\n\n    touchRef.current.on(\"panstart\", handleDragStart);\n    touchRef.current.on(\"panmove\", handleDrag);\n    touchRef.current.on(\"panend\", handleDragEnd);\n\n    if (props.sliderController) {\n      props.sliderController({\n        index: () => _index,\n        // legacy\n        state,\n        hasNext,\n        hasPrevious,\n        goTo,\n        goCurrent,\n        goNext,\n        goPrevious\n      });\n    }\n\n    return () => {\n      touchRef.current.off(\"panstart\", handleDragStart);\n      touchRef.current.off(\"panmove\", handleDrag);\n      touchRef.current.off(\"panend\", handleDragEnd);\n    };\n  }, [touchRef.current, _index, groupBy]); // Each render\n\n  useEffect(() => {\n    if (!contentElement) {\n      return;\n    } // Sizes need to be set each redraw because of screen resizes\n\n\n    if (groupBy !== props.groupBy) {\n      actions.setGroupBy(props.groupBy || 1);\n      updateContentSize(contentElement);\n      goCurrent();\n    } else {\n      updateContentSize(contentElement);\n    }\n  });\n  const componentProps = Object.assign({}, getRef(dom => dom && !domElement && (setDomElement(dom), props.getRef && props.getRef(dom))), props.testId && {\n    \"data-test-id\": props.testId\n  }, {\n    className: [classes.slider, props.className || props.class].join(\" \")\n  });\n  return h(\"div\", componentProps, [props.before ? h(\".\" + classes.before, props.before) : null, h(\"div\", {\n    className: classes.content\n  }, list.map((data, listIndex) => props.page({\n    data,\n    listIndex,\n    currentIndex: _index\n  }))), props.after ? h(\".\" + classes.after, props.after) : null]);\n};\n\nconst css = [{\n  \".mithril-slider\": {\n    overflow: \"hidden\",\n    \" .mithril-slider__content\": {\n      transitionProperty: \"transform\",\n      transitionTimingFunction: \"ease-out\",\n      // transition-duration set in js\n      transform: \"translate3d(0, 0, 0)\"\n    }\n  }\n}];\n\nexport { _Slider, css };\n","import react, { forwardRef } from 'react';\nexport { useCallback, useEffect, useLayoutEffect, useMemo, useReducer, useRef, useState } from 'react';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\n/* eslint-disable complexity, max-statements */\n\nvar classIdSplit = /([\\.#]?[a-zA-Z0-9_:-]+)/;\nvar notClassId = /^\\.|#/;\nvar parseTag_1 = parseTag;\n\nfunction parseTag(tag, props) {\n  if (!tag) {\n    return 'div';\n  }\n\n  var noId = !('id' in props);\n  var tagParts = tag.split(classIdSplit);\n  var tagName = null;\n\n  if (notClassId.test(tagParts[1])) {\n    tagName = 'div';\n  }\n\n  var classes;\n  var part;\n  var type;\n  var i;\n\n  for (i = 0; i < tagParts.length; i++) {\n    part = tagParts[i];\n\n    if (!part) {\n      continue;\n    }\n\n    type = part.charAt(0);\n\n    if (!tagName) {\n      tagName = part;\n    } else if (type === '.') {\n      classes = classes || [];\n      classes.push(part.substring(1, part.length));\n    } else if (type === '#' && noId) {\n      props.id = part.substring(1, part.length);\n    }\n  }\n\n  if (classes) {\n    if (props.className) {\n      classes.push(props.className);\n    }\n\n    props.className = classes.join(' ');\n  }\n\n  return tagName ? tagName.toLowerCase() : 'div';\n}\n\nvar reactHyperscript = h;\n\nfunction h(componentOrTag, properties, children) {\n  // if only one argument which is an array, wrap items with React.Fragment\n  if (arguments.length === 1 && Array.isArray(componentOrTag)) {\n    return h(react.Fragment, null, componentOrTag);\n  } else if (!children && isChildren(properties)) {\n    // If a child array or text node are passed as the second argument, shift them\n    children = properties;\n    properties = {};\n  } else if (arguments.length === 2) {\n    // If no children were passed, we don't want to pass \"undefined\"\n    // and potentially overwrite the `children` prop\n    children = [];\n  }\n\n  properties = properties ? Object.assign({}, properties) : {}; // Supported nested dataset attributes\n\n  if (properties.dataset) {\n    Object.keys(properties.dataset).forEach(function unnest(attrName) {\n      var dashedAttr = attrName.replace(/([a-z])([A-Z])/, function dash(match) {\n        return match[0] + '-' + match[1].toLowerCase();\n      });\n      properties['data-' + dashedAttr] = properties.dataset[attrName];\n    });\n    properties.dataset = undefined;\n  } // Support nested attributes\n\n\n  if (properties.attributes) {\n    Object.keys(properties.attributes).forEach(function unnest(attrName) {\n      properties[attrName] = properties.attributes[attrName];\n    });\n    properties.attributes = undefined;\n  } // When a selector, parse the tag name and fill out the properties object\n\n\n  if (typeof componentOrTag === 'string') {\n    componentOrTag = parseTag_1(componentOrTag, properties);\n  } // Create the element\n\n\n  var args = [componentOrTag, properties].concat(children);\n  return react.createElement.apply(react, args);\n}\n\nfunction isChildren(x) {\n  return typeof x === 'string' || typeof x === 'number' || Array.isArray(x);\n}\n\nvar htmlAttributes = {\n  accept: \"accept\",\n  acceptcharset: \"acceptCharset\",\n  accesskey: \"accessKey\",\n  action: \"action\",\n  allowfullscreen: \"allowFullScreen\",\n  allowtransparency: \"allowTransparency\",\n  alt: \"alt\",\n  async: \"async\",\n  autocomplete: \"autoComplete\",\n  autofocus: \"autoFocus\",\n  autoplay: \"autoPlay\",\n  capture: \"capture\",\n  cellpadding: \"cellPadding\",\n  cellspacing: \"cellSpacing\",\n  challenge: \"challenge\",\n  charset: \"charSet\",\n  checked: \"checked\",\n  class: \"className\",\n  classid: \"classID\",\n  classname: \"className\",\n  className: \"className\",\n  colspan: \"colSpan\",\n  cols: \"cols\",\n  content: \"content\",\n  contenteditable: \"contentEditable\",\n  contextmenu: \"contextMenu\",\n  controls: \"controls\",\n  coords: \"coords\",\n  crossorigin: \"crossOrigin\",\n  data: \"data\",\n  datetime: \"dateTime\",\n  default: \"default\",\n  defer: \"defer\",\n  dir: \"dir\",\n  disabled: \"disabled\",\n  download: \"download\",\n  draggable: \"draggable\",\n  enctype: \"encType\",\n  form: \"form\",\n  formaction: \"formAction\",\n  formenctype: \"formEncType\",\n  formmethod: \"formMethod\",\n  formnovalidate: \"formNoValidate\",\n  formtarget: \"formTarget\",\n  frameborder: \"frameBorder\",\n  headers: \"headers\",\n  height: \"height\",\n  hidden: \"hidden\",\n  high: \"high\",\n  href: \"href\",\n  hreflang: \"hrefLang\",\n  htmlfor: \"htmlFor\",\n  httpequiv: \"httpEquiv\",\n  icon: \"icon\",\n  id: \"id\",\n  inputmode: \"inputMode\",\n  integrity: \"integrity\",\n  is: \"is\",\n  keyparams: \"keyParams\",\n  keytype: \"keyType\",\n  kind: \"kind\",\n  label: \"label\",\n  lang: \"lang\",\n  list: \"list\",\n  loop: \"loop\",\n  low: \"low\",\n  manifest: \"manifest\",\n  marginheight: \"marginHeight\",\n  marginwidth: \"marginWidth\",\n  max: \"max\",\n  maxlength: \"maxLength\",\n  media: \"media\",\n  mediagroup: \"mediaGroup\",\n  method: \"method\",\n  min: \"min\",\n  minlength: \"minLength\",\n  multiple: \"multiple\",\n  muted: \"muted\",\n  name: \"name\",\n  novalidate: \"noValidate\",\n  nonce: \"nonce\",\n  onblur: \"onBlur\",\n  onchange: \"onChange\",\n  onclick: \"onClick\",\n  onfocus: \"onFocus\",\n  oninput: \"onInput\",\n  onkeydown: \"onKeyDown\",\n  onkeyup: \"onKeyUp\",\n  onmousedown: \"onMouseDown\",\n  onmouseout: \"onMouseOut\",\n  onmouseover: \"onMouseOver\",\n  onmouseup: \"onMouseUp\",\n  onscroll: \"onScroll\",\n  onsubmit: \"onSubmit\",\n  ontouchend: \"onTouchEnd\",\n  ontouchmove: \"onTouchMove\",\n  ontouchstart: \"onTouchStart\",\n  open: \"open\",\n  optimum: \"optimum\",\n  pattern: \"pattern\",\n  placeholder: \"placeholder\",\n  poster: \"poster\",\n  preload: \"preload\",\n  radiogroup: \"radioGroup\",\n  readonly: \"readOnly\",\n  rel: \"rel\",\n  required: \"required\",\n  reversed: \"reversed\",\n  role: \"role\",\n  rowspan: \"rowSpan\",\n  rows: \"rows\",\n  sandbox: \"sandbox\",\n  scope: \"scope\",\n  scoped: \"scoped\",\n  scrolling: \"scrolling\",\n  seamless: \"seamless\",\n  selected: \"selected\",\n  shape: \"shape\",\n  size: \"size\",\n  sizes: \"sizes\",\n  span: \"span\",\n  spellcheck: \"spellCheck\",\n  src: \"src\",\n  srcdoc: \"srcDoc\",\n  srclang: \"srcLang\",\n  srcset: \"srcSet\",\n  start: \"start\",\n  step: \"step\",\n  style: \"style\",\n  summary: \"summary\",\n  tabindex: \"tabIndex\",\n  target: \"target\",\n  title: \"title\",\n  type: \"type\",\n  usemap: \"useMap\",\n  value: \"value\",\n  width: \"width\",\n  wmode: \"wmode\",\n  wrap: \"wrap\"\n};\n\nconst a = htmlAttributes;\nconst h$1 = reactHyperscript || {};\n\nh$1.trust = function (html) {\n  let wrapper = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  return reactHyperscript(wrapper, {\n    dangerouslySetInnerHTML: {\n      __html: html\n    }\n  });\n};\n\nh$1.displayName = \"react\";\nconst jsx = react.createElement;\nconst getRef = fn => ({\n  ref: dom => fn(dom)\n});\nconst cast = (component, initialProps) => forwardRef(function () {\n  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let ref = arguments.length > 1 ? arguments[1] : undefined;\n  return component(_objectSpread({}, initialProps, props, {\n    ref\n  }));\n});\n\nexport { a, cast, getRef, h$1 as h, jsx };\n","import { _Slider, css } from \"cyano-core-slider\";\nimport { cast, h, useReducer, useState, useEffect, useRef, getRef } from \"cyano-react\";\n\nexport const Slider = cast(_Slider, { h, useReducer, getRef, useState, useEffect, useRef });\nexport { css };\n"],"names":["_objectWithoutProperties","source","excluded","key","i","target","sourceKeys","Object","keys","length","indexOf","_objectWithoutPropertiesLoose","getOwnPropertySymbols","sourceSymbolKeys","prototype","propertyIsEnumerable","call","_slicedToArray","arr","Array","isArray","_arrayWithHoles","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","value","err","_iterableToArrayLimit","TypeError","_nonIterableRest","classes","slider","content","before","after","O","a","b","arguments","apply","copy","hasOwnProperty","_typeof","this","x","y","constructor","z","module","window","document","exportName","undefined$1","assign","VENDOR_PREFIXES","TEST_ELEMENT","createElement","TYPE_FUNCTION","round","Math","abs","now","Date","setTimeoutContext","fn","timeout","context","setTimeout","bindFn","invokeArrayArg","arg","each","obj","forEach","deprecate","method","name","message","deprecationMessage","e","Error","stack","replace","log","console","warn","output","index","nextKey","extend","dest","src","merge","inherit","child","base","properties","childP","baseP","create","_super","boolOrFn","val","args","ifUndefined","val1","val2","addEventListeners","types","handler","splitStr","type","addEventListener","removeEventListeners","removeEventListener","hasParent","node","parent","parentNode","inStr","str","find","trim","split","inArray","findByKey","toArray","slice","uniqueArray","sort","results","values","prefixed","property","prefix","prop","camelProp","toUpperCase","_uniqueId","getWindowForElement","element","doc","ownerDocument","defaultView","parentWindow","SUPPORT_TOUCH","SUPPORT_POINTER_EVENTS","SUPPORT_ONLY_TOUCH","test","navigator","userAgent","COMPUTE_INTERVAL","INPUT_START","INPUT_MOVE","INPUT_END","INPUT_CANCEL","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL","PROPS_XY","PROPS_CLIENT_XY","Input","manager","callback","self","options","inputTarget","domHandler","ev","enable","init","inputHandler","eventType","input","pointersLen","pointers","changedPointersLen","changedPointers","isFirst","isFinal","session","pointersLength","firstInput","simpleCloneInputData","firstMultiple","offsetCenter","center","getCenter","timeStamp","deltaTime","angle","getAngle","distance","getDistance","offset","offsetDelta","prevDelta","prevInput","deltaX","deltaY","computeDeltaXY","offsetDirection","getDirection","overallVelocity","getVelocity","overallVelocityX","overallVelocityY","scale","start","end","rotation","getRotation","maxPointers","velocity","velocityX","velocityY","direction","last","lastInterval","v","computeIntervalInputData","srcEvent","computeInputData","emit","recognize","clientX","clientY","p1","p2","props","sqrt","atan2","PI","evEl","evTarget","evWin","destroy","MOUSE_INPUT_MAP","mousedown","mousemove","mouseup","MOUSE_ELEMENT_EVENTS","MOUSE_WINDOW_EVENTS","MouseInput","pressed","button","which","pointerType","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","PointerEventInput","store","pointerEvents","MSPointerEvent","PointerEvent","removePointer","eventTypeNormalized","toLowerCase","isTouch","storeIndex","pointerId","splice","SINGLE_TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","SINGLE_TOUCH_TARGET_EVENTS","SINGLE_TOUCH_WINDOW_EVENTS","SingleTouchInput","started","touches","all","changed","changedTouches","concat","TOUCH_INPUT_MAP","TOUCH_TARGET_EVENTS","TouchInput","targetIds","allTouches","identifier","targetTouches","changedTargetTouches","filter","touch","DEDUP_TIMEOUT","DEDUP_DISTANCE","TouchMouseInput","mouse","primaryTouch","lastTouches","setLastTouch","eventData","lastTouch","lts","inputEvent","inputData","isMouse","sourceCapabilities","firesTouchEvents","t","dx","dy","PREFIXED_TOUCH_ACTION","style","NATIVE_TOUCH_ACTION","TOUCH_ACTION_AUTO","TOUCH_ACTION_MANIPULATION","TOUCH_ACTION_NONE","TOUCH_ACTION_PAN_X","TOUCH_ACTION_PAN_Y","TOUCH_ACTION_MAP","touchMap","cssSupports","CSS","supports","getTouchActionProps","TouchAction","set","compute","actions","update","touchAction","recognizers","recognizer","getTouchAction","hasPanX","hasPanY","cleanTouchActions","join","preventDefaults","prevented","preventDefault","hasNone","isTapPointer","isTapMovement","isTapTouchTime","preventSrc","STATE_POSSIBLE","STATE_BEGAN","STATE_CHANGED","STATE_ENDED","STATE_RECOGNIZED","STATE_CANCELLED","Recognizer","defaults","id","state","simultaneous","requireFail","stateStr","directionStr","getRecognizerByNameIfManager","otherRecognizer","get","AttrRecognizer","PanRecognizer","pX","pY","PinchRecognizer","PressRecognizer","_timer","_input","RotateRecognizer","SwipeRecognizer","TapRecognizer","pTime","pCenter","count","Hammer","preset","Manager","recognizeWith","dropRecognizeWith","requireFailure","dropRequireFailure","hasRequireFailures","canRecognizeWith","event","additionalEvent","tryEmit","canEmit","inputDataClone","reset","process","attrTest","optionPointers","isRecognized","isValid","threshold","directionTest","hasMoved","inOut","time","validPointers","validMovement","validTime","clearTimeout","taps","interval","posThreshold","validTouchTime","failTimeout","validInterval","validMultiTap","tapCount","VERSION","domEvents","inputClass","cssProps","userSelect","touchSelect","touchCallout","contentZooming","userDrag","tapHighlightColor","handlers","oldCssProps","toggleCssProps","item","add","stop","force","stopped","curRecognizer","existing","remove","on","events","off","data","gestureEvent","createEvent","initEvent","gesture","dispatchEvent","triggerDomEvent","STATE_FAILED","Tap","Pan","Swipe","Pinch","Rotate","Press","amd","exports","Touch","_ref","el","orientation","hammer","_defineProperty","defineProperty","enumerable","configurable","writable","classIdSplit","notClassId","parseTag_1","tag","part","noId","tagParts","tagName","charAt","substring","className","reactHyperscript","h","componentOrTag","children","react","Fragment","dataset","attrName","dashedAttr","match","attributes","h$1","trust","html","wrapper","dangerouslySetInnerHTML","__html","displayName","component","initialProps","Slider","_ref2","useReducer","useState","useEffect","useRef","getRef","_useReducer2","list","groupBy","pageSize","setIndex","newIndex","setList","newList","setGroupBy","setPageSize","Actions","current","_useState2","domElement","setDomElement","_useState4","contentElement","setContentElement","touchRef","_index","contentChildLength","childNodes","duration","parseInt","cancelDragFactor","isVertical","dir","rtl","pageOffsetX","pageOffsetY","hasPrevious","hasNext","getPageElement","setTransitionStyle","transform","createStyleProps","setTransitionDurationStyle","goTo","idx","updateContentSize","getState","page","pageElement","updateIndex","getNormalizedStep","size","max","getBoundingClientRect","newPageSize","goCurrent","goNext","dur","goPrevious","handleDragStart","handleDrag","delta","origin","offsetTop","offsetLeft","clientWidth","handleDragEnd","calculateTransitionDuration","width","pageData","then","result","querySelector","sliderController","dom","testId","map","listIndex","currentIndex","ref","forwardRef","ownKeys","sym","getOwnPropertyDescriptor","_objectSpread","overflow","transitionProperty","transitionTimingFunction"],"mappings":"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"}